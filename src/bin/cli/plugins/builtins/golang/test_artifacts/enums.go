// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/cartridge-gg/cainome"
	"math/big"
	"github.com/NethermindEth/starknet.go/utils"
)

// SimpleEnum represents a Cairo enum type
type SimpleEnum interface {
	IsSimpleEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
}

const (
	SimpleEnum_Variant1 = "Variant1"
	SimpleEnum_Variant2 = "Variant2"
)

type SimpleEnumVariant1 struct {}

func NewSimpleEnumVariant1() SimpleEnumVariant1 {
	return SimpleEnumVariant1{}
}

// IsSimpleEnum implements the SimpleEnum interface
func (v SimpleEnumVariant1) IsSimpleEnum() bool {
	return true
}

// MarshalCairo serializes SimpleEnumVariant1 to Cairo felt array
func (s *SimpleEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes SimpleEnumVariant1 from Cairo felt array
func (s *SimpleEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for SimpleEnumVariant1
func (s *SimpleEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type SimpleEnumVariant2 struct {}

func NewSimpleEnumVariant2() SimpleEnumVariant2 {
	return SimpleEnumVariant2{}
}

// IsSimpleEnum implements the SimpleEnum interface
func (v SimpleEnumVariant2) IsSimpleEnum() bool {
	return true
}

// MarshalCairo serializes SimpleEnumVariant2 to Cairo felt array
func (s *SimpleEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes SimpleEnumVariant2 from Cairo felt array
func (s *SimpleEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for SimpleEnumVariant2
func (s *SimpleEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}


// EnumsEvent represents a contract event
type EnumsEvent interface {
	IsEnumsEvent() bool
}


// TypedEnum represents a Cairo enum type
type TypedEnum interface {
	IsTypedEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
}

const (
	TypedEnum_Variant1 = "Variant1"
	TypedEnum_Variant2 = "Variant2"
	TypedEnum_Variant3 = "Variant3"
)

type TypedEnumVariant1 struct {
	Data *felt.Felt `json:"data"`
}

func NewTypedEnumVariant1(data *felt.Felt) TypedEnumVariant1 {
	return TypedEnumVariant1 {Data: data}
}

// IsTypedEnum implements the TypedEnum interface
func (v TypedEnumVariant1) IsTypedEnum() bool {
	return true
}

// MarshalCairo serializes TypedEnumVariant1 to Cairo felt array
func (t *TypedEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	result = append(result, t.Data)

	return result, nil
}

// UnmarshalCairo deserializes TypedEnumVariant1 from Cairo felt array
func (t *TypedEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	t.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for TypedEnumVariant1
func (t *TypedEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type TypedEnumVariant2 struct {
	Data *big.Int `json:"data"`
}

func NewTypedEnumVariant2(data *big.Int) TypedEnumVariant2 {
	return TypedEnumVariant2 {Data: data}
}

// IsTypedEnum implements the TypedEnum interface
func (v TypedEnumVariant2) IsTypedEnum() bool {
	return true
}

// MarshalCairo serializes TypedEnumVariant2 to Cairo felt array
func (t *TypedEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	result = append(result, cainome.FeltFromBigInt(t.Data))

	return result, nil
}

// UnmarshalCairo deserializes TypedEnumVariant2 from Cairo felt array
func (t *TypedEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	t.Data = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for TypedEnumVariant2
func (t *TypedEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}

type TypedEnumVariant3 struct {
	Data struct {
	Field0 *felt.Felt
	Field1 *big.Int
} `json:"data"`
}

func NewTypedEnumVariant3(data struct {
	Field0 *felt.Felt
	Field1 *big.Int
}) TypedEnumVariant3 {
	return TypedEnumVariant3 {Data: data}
}

// IsTypedEnum implements the TypedEnum interface
func (v TypedEnumVariant3) IsTypedEnum() bool {
	return true
}

// MarshalCairo serializes TypedEnumVariant3 to Cairo felt array
func (t *TypedEnumVariant3) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(2))
	result = append(result, t.Data.Field0)
	result = append(result, cainome.FeltFromBigInt(t.Data.Field1))

	return result, nil
}

// UnmarshalCairo deserializes TypedEnumVariant3 from Cairo felt array
func (t *TypedEnumVariant3) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 2 {
		return fmt.Errorf("expected discriminant 2, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 0")
	}
	t.Data.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 1")
	}
	t.Data.Field1 = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for TypedEnumVariant3
func (t *TypedEnumVariant3) CairoSize() int {
	return -1 // Dynamic size
}


// MixedEnum represents a Cairo enum type
type MixedEnum interface {
	IsMixedEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
}

const (
	MixedEnum_Variant1 = "Variant1"
	MixedEnum_Variant2 = "Variant2"
)

type MixedEnumVariant1 struct {
	Data *felt.Felt `json:"data"`
}

func NewMixedEnumVariant1(data *felt.Felt) MixedEnumVariant1 {
	return MixedEnumVariant1 {Data: data}
}

// IsMixedEnum implements the MixedEnum interface
func (v MixedEnumVariant1) IsMixedEnum() bool {
	return true
}

// MarshalCairo serializes MixedEnumVariant1 to Cairo felt array
func (m *MixedEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	result = append(result, m.Data)

	return result, nil
}

// UnmarshalCairo deserializes MixedEnumVariant1 from Cairo felt array
func (m *MixedEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	m.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for MixedEnumVariant1
func (m *MixedEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type MixedEnumVariant2 struct {}

func NewMixedEnumVariant2() MixedEnumVariant2 {
	return MixedEnumVariant2{}
}

// IsMixedEnum implements the MixedEnum interface
func (v MixedEnumVariant2) IsMixedEnum() bool {
	return true
}

// MarshalCairo serializes MixedEnumVariant2 to Cairo felt array
func (m *MixedEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes MixedEnumVariant2 from Cairo felt array
func (m *MixedEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for MixedEnumVariant2
func (m *MixedEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}


type EnumsReader struct {
	contractAddress *felt.Felt
	provider rpc.RpcProvider
}

type EnumsWriter struct {
	contractAddress *felt.Felt
	account *account.Account
}

type Enums struct {
	*EnumsReader
	*EnumsWriter
}

func NewEnumsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *EnumsReader {
	return &EnumsReader {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func NewEnumsWriter(contractAddress *felt.Felt, account *account.Account) *EnumsWriter {
	return &EnumsWriter {
		contractAddress: contractAddress,
		account: account,
	}
}

func NewEnums(contractAddress *felt.Felt, account *account.Account) *Enums {
	return &Enums {
		EnumsReader: NewEnumsReader(contractAddress, account.Provider),
		EnumsWriter: NewEnumsWriter(contractAddress, account),
	}
}

func (enums_reader *EnumsReader) GetSimple1(ctx context.Context, opts *cainome.CallOpts) (SimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result SimpleEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result SimpleEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetSimple2(ctx context.Context, opts *cainome.CallOpts) (SimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result SimpleEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result SimpleEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped1(ctx context.Context, opts *cainome.CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result TypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result TypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result TypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped2(ctx context.Context, opts *cainome.CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result TypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result TypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result TypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped3(ctx context.Context, opts *cainome.CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_3"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result TypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result TypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result TypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetMixed1(ctx context.Context, opts *cainome.CallOpts) (MixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result MixedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result MixedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetMixed2(ctx context.Context, opts *cainome.CallOpts) (MixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result MixedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result MixedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

