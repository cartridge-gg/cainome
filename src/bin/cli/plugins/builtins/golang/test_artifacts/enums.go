// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

type MixedEnum struct {
	Variant string `json:"variant"`
	Value   interface{} `json:"value,omitempty"`
}

const (
	MixedEnum_Variant1 = "Variant1"
	MixedEnum_Variant2 = "Variant2"
)

func NewMixedEnumVariant1() MixedEnum {
	return MixedEnum {
		Variant: "Variant1",
	}
}

func NewMixedEnumVariant2() MixedEnum {
	return MixedEnum {
		Variant: "Variant2",
	}
}

// MarshalCairo serializes MixedEnum to Cairo felt array
func (e *MixedEnum) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	switch e.Variant {
	case "Variant1":
		// Discriminant for variant Variant1
		result = append(result, FeltFromUint(0))
		// Unit variant - no additional data
	case "Variant2":
		// Discriminant for variant Variant2
		result = append(result, FeltFromUint(1))
		// Unit variant - no additional data
	default:
		return nil, fmt.Errorf("unknown variant: %s", e.Variant)
	}

	return result, nil
}

// UnmarshalCairo deserializes MixedEnum from Cairo felt array
func (e *MixedEnum) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := UintFromFelt(data[0])
	offset := 1

	switch discriminant {
	case 0:
		e.Variant = "Variant1"
		e.Value = nil
	case 1:
		e.Variant = "Variant2"
		e.Value = nil
	default:
		return fmt.Errorf("unknown discriminant: %d", discriminant)
	}

	_ = offset // Suppress unused variable warning for unit-only enums
	return nil
}

// CairoSize returns the serialized size for MixedEnum
func (e *MixedEnum) CairoSize() int {
	return -1 // Dynamic size
}


// EnumsEvent represents a contract event
type EnumsEvent interface {
	IsEnumsEvent() bool
}


type SimpleEnum struct {
	Variant string `json:"variant"`
	Value   interface{} `json:"value,omitempty"`
}

const (
	SimpleEnum_Variant1 = "Variant1"
	SimpleEnum_Variant2 = "Variant2"
)

func NewSimpleEnumVariant1() SimpleEnum {
	return SimpleEnum {
		Variant: "Variant1",
	}
}

func NewSimpleEnumVariant2() SimpleEnum {
	return SimpleEnum {
		Variant: "Variant2",
	}
}

// MarshalCairo serializes SimpleEnum to Cairo felt array
func (e *SimpleEnum) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	switch e.Variant {
	case "Variant1":
		// Discriminant for variant Variant1
		result = append(result, FeltFromUint(0))
		// Unit variant - no additional data
	case "Variant2":
		// Discriminant for variant Variant2
		result = append(result, FeltFromUint(1))
		// Unit variant - no additional data
	default:
		return nil, fmt.Errorf("unknown variant: %s", e.Variant)
	}

	return result, nil
}

// UnmarshalCairo deserializes SimpleEnum from Cairo felt array
func (e *SimpleEnum) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := UintFromFelt(data[0])
	offset := 1

	switch discriminant {
	case 0:
		e.Variant = "Variant1"
		e.Value = nil
	case 1:
		e.Variant = "Variant2"
		e.Value = nil
	default:
		return fmt.Errorf("unknown discriminant: %d", discriminant)
	}

	_ = offset // Suppress unused variable warning for unit-only enums
	return nil
}

// CairoSize returns the serialized size for SimpleEnum
func (e *SimpleEnum) CairoSize() int {
	return -1 // Dynamic size
}


type TypedEnum struct {
	Variant string `json:"variant"`
	Value   interface{} `json:"value,omitempty"`
}

const (
	TypedEnum_Variant1 = "Variant1"
	TypedEnum_Variant2 = "Variant2"
	TypedEnum_Variant3 = "Variant3"
)

func NewTypedEnumVariant1() TypedEnum {
	return TypedEnum {
		Variant: "Variant1",
	}
}

func NewTypedEnumVariant2() TypedEnum {
	return TypedEnum {
		Variant: "Variant2",
	}
}

func NewTypedEnumVariant3() TypedEnum {
	return TypedEnum {
		Variant: "Variant3",
	}
}

// MarshalCairo serializes TypedEnum to Cairo felt array
func (e *TypedEnum) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	switch e.Variant {
	case "Variant1":
		// Discriminant for variant Variant1
		result = append(result, FeltFromUint(0))
		// Unit variant - no additional data
	case "Variant2":
		// Discriminant for variant Variant2
		result = append(result, FeltFromUint(1))
		// Unit variant - no additional data
	case "Variant3":
		// Discriminant for variant Variant3
		result = append(result, FeltFromUint(2))
		// Unit variant - no additional data
	default:
		return nil, fmt.Errorf("unknown variant: %s", e.Variant)
	}

	return result, nil
}

// UnmarshalCairo deserializes TypedEnum from Cairo felt array
func (e *TypedEnum) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := UintFromFelt(data[0])
	offset := 1

	switch discriminant {
	case 0:
		e.Variant = "Variant1"
		e.Value = nil
	case 1:
		e.Variant = "Variant2"
		e.Value = nil
	case 2:
		e.Variant = "Variant3"
		e.Value = nil
	default:
		return fmt.Errorf("unknown discriminant: %d", discriminant)
	}

	_ = offset // Suppress unused variable warning for unit-only enums
	return nil
}

// CairoSize returns the serialized size for TypedEnum
func (e *TypedEnum) CairoSize() int {
	return -1 // Dynamic size
}


type Enums struct {
	contractAddress *felt.Felt
	provider *rpc.Provider
}

func NewEnums(contractAddress *felt.Felt, provider *rpc.Provider) *Enums {
	return &Enums {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func (enums *Enums) GetSimple1(ctx context.Context, opts *CallOpts) (SimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_1"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return SimpleEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return SimpleEnum{}, fmt.Errorf("empty response")
	}
	var result SimpleEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return SimpleEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetSimple2(ctx context.Context, opts *CallOpts) (SimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_2"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return SimpleEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return SimpleEnum{}, fmt.Errorf("empty response")
	}
	var result SimpleEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return SimpleEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetTyped1(ctx context.Context, opts *CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_1"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return TypedEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return TypedEnum{}, fmt.Errorf("empty response")
	}
	var result TypedEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return TypedEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetTyped2(ctx context.Context, opts *CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_2"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return TypedEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return TypedEnum{}, fmt.Errorf("empty response")
	}
	var result TypedEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return TypedEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetTyped3(ctx context.Context, opts *CallOpts) (TypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_3"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return TypedEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return TypedEnum{}, fmt.Errorf("empty response")
	}
	var result TypedEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return TypedEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetMixed1(ctx context.Context, opts *CallOpts) (MixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_1"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return MixedEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return MixedEnum{}, fmt.Errorf("empty response")
	}
	var result MixedEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return MixedEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

func (enums *Enums) GetMixed2(ctx context.Context, opts *CallOpts) (MixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_2"),
		Calldata:           calldata,
	}

	response, err := enums.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return MixedEnum{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return MixedEnum{}, fmt.Errorf("empty response")
	}
	var result MixedEnum
	// TODO: Deserialize using UnmarshalCairo()
	// if err := result.UnmarshalCairo(response); err != nil {
	//     return MixedEnum{}, fmt.Errorf("failed to unmarshal response: %w", err)
	// }
	_ = response // TODO: implement UnmarshalCairo and deserialize response into result
	return result, nil
}

