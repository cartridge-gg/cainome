// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/cartridge-gg/cainome"
	"math/big"
)

type EnumsSimple struct {
	Address *felt.Felt `json:"address"`
	Felt *felt.Felt `json:"felt"`
	Uint256 *big.Int `json:"uint256"`
	Uint64 uint64 `json:"uint64"`
}

// MarshalCairo serializes EnumsSimple to Cairo felt array
func (s *EnumsSimple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Address)
	result = append(result, s.Felt)
	result = append(result, cainome.FeltFromBigInt(s.Uint256))
	result = append(result, cainome.FeltFromUint(uint64(s.Uint64)))
	return result, nil
}

// UnmarshalCairo deserializes EnumsSimple from Cairo felt array
func (s *EnumsSimple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Address")
	}
	s.Address = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Felt")
	}
	s.Felt = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint256")
	}
	s.Uint256 = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint64")
	}
	s.Uint64 = cainome.UintFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for EnumsSimple
func (s *EnumsSimple) CairoSize() int {
	return -1 // Dynamic size
}


type EnumsStructWithStruct struct {
	Simple EnumsSimple `json:"simple"`
}

// MarshalCairo serializes EnumsStructWithStruct to Cairo felt array
func (s *EnumsStructWithStruct) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Struct field Simple: marshal using CairoMarshaler
	if fieldData, err := s.Simple.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	return result, nil
}

// UnmarshalCairo deserializes EnumsStructWithStruct from Cairo felt array
func (s *EnumsStructWithStruct) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Struct field Simple: unmarshal using CairoMarshaler
	if err := s.Simple.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	return nil
}

// CairoSize returns the serialized size for EnumsStructWithStruct
func (s *EnumsStructWithStruct) CairoSize() int {
	return -1 // Dynamic size
}


// EnumsMixedEnum represents a Cairo enum type
type EnumsMixedEnum interface {
	IsEnumsMixedEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	EnumsMixedEnum_Variant1 = "Variant1"
	EnumsMixedEnum_Variant2 = "Variant2"
)

type EnumsMixedEnumVariant1 struct {
	Data *felt.Felt `json:"data"`
}

func NewEnumsMixedEnumVariant1(data *felt.Felt) EnumsMixedEnumVariant1 {
	return EnumsMixedEnumVariant1 {Data: data}
}

// IsEnumsMixedEnum implements the EnumsMixedEnum interface
func (v EnumsMixedEnumVariant1) IsEnumsMixedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsMixedEnumVariant1 to Cairo felt array
func (e *EnumsMixedEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	result = append(result, e.Data)

	return result, nil
}

// UnmarshalCairo deserializes EnumsMixedEnumVariant1 from Cairo felt array
func (e *EnumsMixedEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	e.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for EnumsMixedEnumVariant1
func (e *EnumsMixedEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsMixedEnumVariant2 struct {}

func NewEnumsMixedEnumVariant2() EnumsMixedEnumVariant2 {
	return EnumsMixedEnumVariant2{}
}

// IsEnumsMixedEnum implements the EnumsMixedEnum interface
func (v EnumsMixedEnumVariant2) IsEnumsMixedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsMixedEnumVariant2 to Cairo felt array
func (e *EnumsMixedEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes EnumsMixedEnumVariant2 from Cairo felt array
func (e *EnumsMixedEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for EnumsMixedEnumVariant2
func (e *EnumsMixedEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}

// UnmarshalEnumsMixedEnumFromCairo deserializes EnumsMixedEnum from Cairo felt array
func UnmarshalEnumsMixedEnumFromCairo(data []*felt.Felt) (EnumsMixedEnum, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("empty data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])

	switch discriminant {
	case 0:
		var result EnumsMixedEnumVariant1
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsMixedEnumVariant2
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}


// EnumsSimpleEnum represents a Cairo enum type
type EnumsSimpleEnum interface {
	IsEnumsSimpleEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	EnumsSimpleEnum_Variant1 = "Variant1"
	EnumsSimpleEnum_Variant2 = "Variant2"
)

type EnumsSimpleEnumVariant1 struct {}

func NewEnumsSimpleEnumVariant1() EnumsSimpleEnumVariant1 {
	return EnumsSimpleEnumVariant1{}
}

// IsEnumsSimpleEnum implements the EnumsSimpleEnum interface
func (v EnumsSimpleEnumVariant1) IsEnumsSimpleEnum() bool {
	return true
}

// MarshalCairo serializes EnumsSimpleEnumVariant1 to Cairo felt array
func (e *EnumsSimpleEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes EnumsSimpleEnumVariant1 from Cairo felt array
func (e *EnumsSimpleEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for EnumsSimpleEnumVariant1
func (e *EnumsSimpleEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsSimpleEnumVariant2 struct {}

func NewEnumsSimpleEnumVariant2() EnumsSimpleEnumVariant2 {
	return EnumsSimpleEnumVariant2{}
}

// IsEnumsSimpleEnum implements the EnumsSimpleEnum interface
func (v EnumsSimpleEnumVariant2) IsEnumsSimpleEnum() bool {
	return true
}

// MarshalCairo serializes EnumsSimpleEnumVariant2 to Cairo felt array
func (e *EnumsSimpleEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes EnumsSimpleEnumVariant2 from Cairo felt array
func (e *EnumsSimpleEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for EnumsSimpleEnumVariant2
func (e *EnumsSimpleEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}

// UnmarshalEnumsSimpleEnumFromCairo deserializes EnumsSimpleEnum from Cairo felt array
func UnmarshalEnumsSimpleEnumFromCairo(data []*felt.Felt) (EnumsSimpleEnum, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("empty data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])

	switch discriminant {
	case 0:
		var result EnumsSimpleEnumVariant1
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsSimpleEnumVariant2
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}


// EnumsTypedEnum represents a Cairo enum type
type EnumsTypedEnum interface {
	IsEnumsTypedEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	EnumsTypedEnum_Variant1 = "Variant1"
	EnumsTypedEnum_Variant2 = "Variant2"
	EnumsTypedEnum_Variant3 = "Variant3"
	EnumsTypedEnum_Variant4 = "Variant4"
	EnumsTypedEnum_Variant5 = "Variant5"
	EnumsTypedEnum_Variant6 = "Variant6"
)

type EnumsTypedEnumVariant1 struct {
	Data *felt.Felt `json:"data"`
}

func NewEnumsTypedEnumVariant1(data *felt.Felt) EnumsTypedEnumVariant1 {
	return EnumsTypedEnumVariant1 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant1) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant1 to Cairo felt array
func (e *EnumsTypedEnumVariant1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	result = append(result, e.Data)

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant1 from Cairo felt array
func (e *EnumsTypedEnumVariant1) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	e.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant1
func (e *EnumsTypedEnumVariant1) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsTypedEnumVariant2 struct {
	Data *big.Int `json:"data"`
}

func NewEnumsTypedEnumVariant2(data *big.Int) EnumsTypedEnumVariant2 {
	return EnumsTypedEnumVariant2 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant2) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant2 to Cairo felt array
func (e *EnumsTypedEnumVariant2) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	result = append(result, cainome.FeltFromBigInt(e.Data))

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant2 from Cairo felt array
func (e *EnumsTypedEnumVariant2) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	e.Data = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant2
func (e *EnumsTypedEnumVariant2) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsTypedEnumVariant3 struct {
	Data struct {
	Field0 *felt.Felt
	Field1 *big.Int
} `json:"data"`
}

func NewEnumsTypedEnumVariant3(data struct {
	Field0 *felt.Felt
	Field1 *big.Int
}) EnumsTypedEnumVariant3 {
	return EnumsTypedEnumVariant3 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant3) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant3 to Cairo felt array
func (e *EnumsTypedEnumVariant3) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(2))
	result = append(result, e.Data.Field0)
	result = append(result, cainome.FeltFromBigInt(e.Data.Field1))

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant3 from Cairo felt array
func (e *EnumsTypedEnumVariant3) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 2 {
		return fmt.Errorf("expected discriminant 2, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 0")
	}
	e.Data.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 1")
	}
	e.Data.Field1 = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant3
func (e *EnumsTypedEnumVariant3) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsTypedEnumVariant4 struct {
	Data *felt.Felt `json:"data"`
}

func NewEnumsTypedEnumVariant4(data *felt.Felt) EnumsTypedEnumVariant4 {
	return EnumsTypedEnumVariant4 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant4) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant4 to Cairo felt array
func (e *EnumsTypedEnumVariant4) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(3))
	result = append(result, e.Data)

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant4 from Cairo felt array
func (e *EnumsTypedEnumVariant4) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 3 {
		return fmt.Errorf("expected discriminant 3, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	e.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant4
func (e *EnumsTypedEnumVariant4) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsTypedEnumVariant5 struct {
	Data EnumsSimple `json:"data"`
}

func NewEnumsTypedEnumVariant5(data EnumsSimple) EnumsTypedEnumVariant5 {
	return EnumsTypedEnumVariant5 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant5) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant5 to Cairo felt array
func (e *EnumsTypedEnumVariant5) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(4))
	if valueData, err := e.Data.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, valueData...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant5 from Cairo felt array
func (e *EnumsTypedEnumVariant5) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 4 {
		return fmt.Errorf("expected discriminant 4, got %d", discriminant)
	}
	offset := 1

	if err := e.Data.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant5
func (e *EnumsTypedEnumVariant5) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsTypedEnumVariant6 struct {
	Data EnumsStructWithStruct `json:"data"`
}

func NewEnumsTypedEnumVariant6(data EnumsStructWithStruct) EnumsTypedEnumVariant6 {
	return EnumsTypedEnumVariant6 {Data: data}
}

// IsEnumsTypedEnum implements the EnumsTypedEnum interface
func (v EnumsTypedEnumVariant6) IsEnumsTypedEnum() bool {
	return true
}

// MarshalCairo serializes EnumsTypedEnumVariant6 to Cairo felt array
func (e *EnumsTypedEnumVariant6) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(5))
	if valueData, err := e.Data.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, valueData...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsTypedEnumVariant6 from Cairo felt array
func (e *EnumsTypedEnumVariant6) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 5 {
		return fmt.Errorf("expected discriminant 5, got %d", discriminant)
	}
	offset := 1

	if err := e.Data.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data
	return nil
}

// CairoSize returns the serialized size for EnumsTypedEnumVariant6
func (e *EnumsTypedEnumVariant6) CairoSize() int {
	return -1 // Dynamic size
}

// UnmarshalEnumsTypedEnumFromCairo deserializes EnumsTypedEnum from Cairo felt array
func UnmarshalEnumsTypedEnumFromCairo(data []*felt.Felt) (EnumsTypedEnum, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("empty data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])

	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}


// EnumsEnumsEvent represents a contract event
type EnumsEnumsEvent interface {
	IsEnumsEnumsEvent() bool
}


type EnumsContract struct {
	contractAddress *felt.Felt
}

func NewEnumsContract(contractAddress *felt.Felt) *EnumsContract {
	return &EnumsContract {
		contractAddress: contractAddress,
	}
}

type EnumsReader struct {
	*EnumsContract
	provider rpc.RpcProvider
}

type EnumsWriter struct {
	*EnumsContract
	account *account.Account
}

type Enums struct {
	*EnumsReader
	*EnumsWriter
}

func NewEnumsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *EnumsReader {
	return &EnumsReader {
		EnumsContract: NewEnumsContract(contractAddress),
		provider: provider,
	}
}

func NewEnumsWriter(contractAddress *felt.Felt, account *account.Account) *EnumsWriter {
	return &EnumsWriter {
		EnumsContract: NewEnumsContract(contractAddress),
		account: account,
	}
}

func NewEnums(contractAddress *felt.Felt, account *account.Account) *Enums {
	return &Enums {
		EnumsReader: NewEnumsReader(contractAddress, account.Provider),
		EnumsWriter: NewEnumsWriter(contractAddress, account),
	}
}

type EnumsGetMixed1Response struct {
	Value EnumsMixedEnum `json:"value"`
}

func NewEnumsGetMixed1Response(value EnumsMixedEnum) *EnumsGetMixed1Response {
	return &EnumsGetMixed1Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetMixed1Response to Cairo felt array
func (s *EnumsGetMixed1Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetMixed1Response from Cairo felt array
func (s *EnumsGetMixed1Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetMixed1Response
func (s *EnumsGetMixed1Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetMixed2Response struct {
	Value EnumsMixedEnum `json:"value"`
}

func NewEnumsGetMixed2Response(value EnumsMixedEnum) *EnumsGetMixed2Response {
	return &EnumsGetMixed2Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetMixed2Response to Cairo felt array
func (s *EnumsGetMixed2Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetMixed2Response from Cairo felt array
func (s *EnumsGetMixed2Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetMixed2Response
func (s *EnumsGetMixed2Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetSimple1Response struct {
	Value EnumsSimpleEnum `json:"value"`
}

func NewEnumsGetSimple1Response(value EnumsSimpleEnum) *EnumsGetSimple1Response {
	return &EnumsGetSimple1Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetSimple1Response to Cairo felt array
func (s *EnumsGetSimple1Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetSimple1Response from Cairo felt array
func (s *EnumsGetSimple1Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetSimple1Response
func (s *EnumsGetSimple1Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetSimple2Response struct {
	Value EnumsSimpleEnum `json:"value"`
}

func NewEnumsGetSimple2Response(value EnumsSimpleEnum) *EnumsGetSimple2Response {
	return &EnumsGetSimple2Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetSimple2Response to Cairo felt array
func (s *EnumsGetSimple2Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetSimple2Response from Cairo felt array
func (s *EnumsGetSimple2Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetSimple2Response
func (s *EnumsGetSimple2Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTyped1Response struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTyped1Response(value EnumsTypedEnum) *EnumsGetTyped1Response {
	return &EnumsGetTyped1Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTyped1Response to Cairo felt array
func (s *EnumsGetTyped1Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTyped1Response from Cairo felt array
func (s *EnumsGetTyped1Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTyped1Response
func (s *EnumsGetTyped1Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTyped2Response struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTyped2Response(value EnumsTypedEnum) *EnumsGetTyped2Response {
	return &EnumsGetTyped2Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTyped2Response to Cairo felt array
func (s *EnumsGetTyped2Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTyped2Response from Cairo felt array
func (s *EnumsGetTyped2Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTyped2Response
func (s *EnumsGetTyped2Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTyped3Response struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTyped3Response(value EnumsTypedEnum) *EnumsGetTyped3Response {
	return &EnumsGetTyped3Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTyped3Response to Cairo felt array
func (s *EnumsGetTyped3Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTyped3Response from Cairo felt array
func (s *EnumsGetTyped3Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTyped3Response
func (s *EnumsGetTyped3Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTyped4Response struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTyped4Response(value EnumsTypedEnum) *EnumsGetTyped4Response {
	return &EnumsGetTyped4Response {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTyped4Response to Cairo felt array
func (s *EnumsGetTyped4Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTyped4Response from Cairo felt array
func (s *EnumsGetTyped4Response) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTyped4Response
func (s *EnumsGetTyped4Response) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTypedWithArgInput struct {
	E EnumsTypedEnum `json:"e"`
}

func NewEnumsGetTypedWithArgInput(e EnumsTypedEnum) *EnumsGetTypedWithArgInput {
	return &EnumsGetTypedWithArgInput {
		E: e,
	}
}

// MarshalCairo serializes EnumsGetTypedWithArgInput to Cairo felt array
func (s *EnumsGetTypedWithArgInput) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if E_data, err := s.E.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, E_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTypedWithArgInput from Cairo felt array
func (s *EnumsGetTypedWithArgInput) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Custom composite field E: unmarshal using CairoMarshaler
	if err := s.E.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTypedWithArgInput
func (s *EnumsGetTypedWithArgInput) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTypedWithArgResponse struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTypedWithArgResponse(value EnumsTypedEnum) *EnumsGetTypedWithArgResponse {
	return &EnumsGetTypedWithArgResponse {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTypedWithArgResponse to Cairo felt array
func (s *EnumsGetTypedWithArgResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if s_Value_data, err := s.Value.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, s_Value_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTypedWithArgResponse from Cairo felt array
func (s *EnumsGetTypedWithArgResponse) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field Value: unmarshal using CairoMarshaler
	if err := s.Value.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for EnumsGetTypedWithArgResponse
func (s *EnumsGetTypedWithArgResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTypedWithOptionArgInput struct {
	E EnumsTypedEnum `json:"e"`
}

func NewEnumsGetTypedWithOptionArgInput(e EnumsTypedEnum) *EnumsGetTypedWithOptionArgInput {
	return &EnumsGetTypedWithOptionArgInput {
		E: e,
	}
}

// MarshalCairo serializes EnumsGetTypedWithOptionArgInput to Cairo felt array
func (s *EnumsGetTypedWithOptionArgInput) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Option field E: check for nil and marshal accordingly
	if s.E != nil {
		// Some variant: discriminant 0 + value
		result = append(result, cainome.FeltFromUint(0))
		if fieldData, err := s.E.MarshalCairo(); err != nil {
			return nil, err
		} else {
			result = append(result, fieldData...)
		}
	} else {
		// None variant: discriminant 1 (no additional data)
		result = append(result, cainome.FeltFromUint(1))
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTypedWithOptionArgInput from Cairo felt array
func (s *EnumsGetTypedWithOptionArgInput) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Option field E: read discriminant then value if Some
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for Option field E discriminant")
	}
	discriminant := cainome.UintFromFelt(data[offset])
	offset++
	if discriminant == 0 {
		// Some variant: read the value
		var value EnumsTypedEnum
		if enumValue, err := UnmarshalEnumsTypedEnumFromCairo(data[offset:]); err != nil {
			return err
		} else {
			value = enumValue
			// TODO: Update offset based on consumed data
		}
		s.E = value
	} else {
		// None variant
		s.E = nil
	}


	return nil
}

// CairoSize returns the serialized size for EnumsGetTypedWithOptionArgInput
func (s *EnumsGetTypedWithOptionArgInput) CairoSize() int {
	return -1 // Dynamic size
}

type EnumsGetTypedWithOptionArgResponse struct {
	Value EnumsTypedEnum `json:"value"`
}

func NewEnumsGetTypedWithOptionArgResponse(value EnumsTypedEnum) *EnumsGetTypedWithOptionArgResponse {
	return &EnumsGetTypedWithOptionArgResponse {
		Value: value,
	}
}

// MarshalCairo serializes EnumsGetTypedWithOptionArgResponse to Cairo felt array
func (s *EnumsGetTypedWithOptionArgResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Option field: check for nil and marshal accordingly
	if s.Value != nil {
		// Some variant: discriminant 0 + value
		result = append(result, cainome.FeltFromUint(0))
		if fieldData, err := s.Value.MarshalCairo(); err != nil {
			return nil, err
		} else {
			result = append(result, fieldData...)
		}
	} else {
		// None variant: discriminant 1 (no additional data)
		result = append(result, cainome.FeltFromUint(1))
	}

	return result, nil
}

// UnmarshalCairo deserializes EnumsGetTypedWithOptionArgResponse from Cairo felt array
func (s *EnumsGetTypedWithOptionArgResponse) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Option field Value: read discriminant then value if Some
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for Option field Value discriminant")
	}
	discriminant := cainome.UintFromFelt(data[offset])
	offset++
	if discriminant == 0 {
		// Some variant: read the value
		if enumValue, err := UnmarshalEnumsTypedEnumFromCairo(data[offset:]); err != nil {
			return err
		} else {
			s.Value = enumValue
			// TODO: Update offset based on consumed data
		}
	} else {
		// None variant
		s.Value = nil
	}


	return nil
}

// CairoSize returns the serialized size for EnumsGetTypedWithOptionArgResponse
func (s *EnumsGetTypedWithOptionArgResponse) CairoSize() int {
	return -1 // Dynamic size
}

func (enums_contract *EnumsContract) GetMixed1() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetMixed1Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetMixed2() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetMixed2Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetSimple1() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetSimple1Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetSimple2() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetSimple2Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped1() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped1Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_1"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped2() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped2Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_2"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped3() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_3"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped3Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_3"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped4() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_4"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTyped4Legacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_4"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTypedWithArg(input *EnumsGetTypedWithArgInput) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_arg"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTypedWithArgLegacy(e EnumsTypedEnum) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if e_data, err := e.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, e_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_arg"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTypedWithOptionArg(input *EnumsGetTypedWithOptionArgInput) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_option_arg"),
		Calldata:           calldata,
	}, nil
}

func (enums_contract *EnumsContract) GetTypedWithOptionArgLegacy(e EnumsTypedEnum) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if e_data, err := e.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, e_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    enums_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_option_arg"),
		Calldata:           calldata,
	}, nil
}

func (enums_reader *EnumsReader) GetMixed1(ctx context.Context, opts *cainome.CallOpts) (EnumsMixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsMixedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsMixedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetMixed2(ctx context.Context, opts *cainome.CallOpts) (EnumsMixedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_mixed_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsMixedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsMixedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetSimple1(ctx context.Context, opts *cainome.CallOpts) (EnumsSimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsSimpleEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsSimpleEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetSimple2(ctx context.Context, opts *cainome.CallOpts) (EnumsSimpleEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsSimpleEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsSimpleEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped1(ctx context.Context, opts *cainome.CallOpts) (EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_1"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped2(ctx context.Context, opts *cainome.CallOpts) (EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_2"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped3(ctx context.Context, opts *cainome.CallOpts) (EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_3"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTyped4(ctx context.Context, opts *cainome.CallOpts) (EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_4"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTypedWithArg(ctx context.Context, e EnumsTypedEnum, opts *cainome.CallOpts) (EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if e_data, err := e.MarshalCairo(); err != nil {
		return nil, err
	} else {
		calldata = append(calldata, e_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_arg"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	
	// Read discriminant to determine variant
	discriminant := cainome.UintFromFelt(response[0])
	
	switch discriminant {
	case 0:
		var result EnumsTypedEnumVariant1
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result EnumsTypedEnumVariant2
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result EnumsTypedEnumVariant3
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result EnumsTypedEnumVariant4
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result EnumsTypedEnumVariant5
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result EnumsTypedEnumVariant6
		if err := result.UnmarshalCairo(response); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}

func (enums_reader *EnumsReader) GetTypedWithOptionArg(ctx context.Context, e EnumsTypedEnum, opts *cainome.CallOpts) (*EnumsTypedEnum, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if e != nil {
		// Some variant
		calldata = append(calldata, cainome.FeltFromUint(0))
		if e_data, err := e.MarshalCairo(); err != nil {
			return nil, err
		} else {
			calldata = append(calldata, e_data...)
		}
	} else {
		// None variant
		calldata = append(calldata, cainome.FeltFromUint(1))
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    enums_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_typed_with_option_arg"),
		Calldata:           calldata,
	}

	response, err := enums_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	// Check Option discriminant
	if cainome.UintFromFelt(response[0]) == 0 {
		// None variant
		return nil, nil
	} else {
		// Some variant - deserialize enum from response[1:]
		if len(response) < 2 {
			return nil, fmt.Errorf("insufficient data for Some variant")
		}
		// Read enum discriminant from response[1]
		discriminant := cainome.UintFromFelt(response[1])
		switch discriminant {
		default:
			return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
		}
	}
}

