// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/cartridge-gg/cainome"
	"math/big"
)

type GenE1 struct {
	Key *felt.Felt `json:"key"`
	Value []*felt.Felt `json:"value"`
}

// MarshalCairo serializes GenE1 to Cairo felt array
func (s *GenE1) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Key)
	// Array field Value: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Value))))
	for _, item := range s.Value {
		result = append(result, item)
	}
	return result, nil
}

// UnmarshalCairo deserializes GenE1 from Cairo felt array
func (s *GenE1) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Key")
	}
	s.Key = data[offset]
	offset++

	// Array field Value: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Value")
	}
	lengthValue := cainome.UintFromFelt(data[offset])
	offset++
	s.Value = make([]*felt.Felt, lengthValue)
	for i := uint64(0); i < lengthValue; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of Value", i)
		}
		s.Value[i] = data[offset]
		offset++
	}

	return nil
}

// CairoSize returns the serialized size for GenE1
func (s *GenE1) CairoSize() int {
	return -1 // Dynamic size
}

// IsGenGenEvent implements the GenGenEvent interface
func (e GenE1) IsGenGenEvent() bool {
	return true
}


type GenMyStructGen struct {
	F1 *felt.Felt `json:"f1"`
	F2 *felt.Felt `json:"f2"`
	F3 *felt.Felt `json:"f3"`
}

// MarshalCairo serializes GenMyStructGen to Cairo felt array
func (s *GenMyStructGen) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.F1)
	result = append(result, s.F2)
	result = append(result, s.F3)
	return result, nil
}

// UnmarshalCairo deserializes GenMyStructGen from Cairo felt array
func (s *GenMyStructGen) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F1")
	}
	s.F1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F2")
	}
	s.F2 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F3")
	}
	s.F3 = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for GenMyStructGen
func (s *GenMyStructGen) CairoSize() int {
	return -1 // Dynamic size
}


type GenMyStructInnerGeneric struct {
	F1 *felt.Felt `json:"f1"`
	F2 GenMyStructGen `json:"f2"`
	F3 uint32 `json:"f3"`
}

// MarshalCairo serializes GenMyStructInnerGeneric to Cairo felt array
func (s *GenMyStructInnerGeneric) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.F1)
	// Struct field F2: marshal using CairoMarshaler
	if fieldData, err := s.F2.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	result = append(result, cainome.FeltFromUint(uint64(s.F3)))
	return result, nil
}

// UnmarshalCairo deserializes GenMyStructInnerGeneric from Cairo felt array
func (s *GenMyStructInnerGeneric) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F1")
	}
	s.F1 = data[offset]
	offset++

	// Struct field F2: unmarshal using CairoMarshaler
	if err := s.F2.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F3")
	}
	s.F3 = uint32(cainome.UintFromFelt(data[offset]))
	offset++

	return nil
}

// CairoSize returns the serialized size for GenMyStructInnerGeneric
func (s *GenMyStructInnerGeneric) CairoSize() int {
	return -1 // Dynamic size
}


type GenPlainStruct struct {
	F1 uint8 `json:"f1"`
	F2 uint16 `json:"f2"`
	F3 uint32 `json:"f3"`
	F4 uint64 `json:"f4"`
	F5 *big.Int `json:"f5"`
	F6 *felt.Felt `json:"f6"`
	F7 struct {
	Field0 *felt.Felt
	Field1 uint64
} `json:"f7"`
	F8 []uint8 `json:"f8"`
	F9 []*big.Int `json:"f9"`
}

// MarshalCairo serializes GenPlainStruct to Cairo felt array
func (s *GenPlainStruct) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromUint(uint64(s.F1)))
	result = append(result, cainome.FeltFromUint(uint64(s.F2)))
	result = append(result, cainome.FeltFromUint(uint64(s.F3)))
	result = append(result, cainome.FeltFromUint(uint64(s.F4)))
	result = append(result, cainome.FeltFromBigInt(s.F5))
	result = append(result, s.F6)
	// Tuple field F7: marshal each sub-field (tuple has 2 elements)
	result = append(result, s.F7.Field0)
	result = append(result, cainome.FeltFromUint(uint64(s.F7.Field1)))
	// Array field F8: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.F8))))
	for _, item := range s.F8 {
		result = append(result, cainome.FeltFromUint(uint64(item)))
	}
	// Array field F9: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.F9))))
	for _, item := range s.F9 {
		result = append(result, cainome.FeltFromBigInt(item))
	}
	return result, nil
}

// UnmarshalCairo deserializes GenPlainStruct from Cairo felt array
func (s *GenPlainStruct) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F1")
	}
	s.F1 = uint8(cainome.UintFromFelt(data[offset]))
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F2")
	}
	s.F2 = uint16(cainome.UintFromFelt(data[offset]))
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F3")
	}
	s.F3 = uint32(cainome.UintFromFelt(data[offset]))
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F4")
	}
	s.F4 = cainome.UintFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F5")
	}
	s.F5 = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field F6")
	}
	s.F6 = data[offset]
	offset++

	// Tuple field F7: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field F7 element 0")
	}
	s.F7.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field F7 element 1")
	}
	s.F7.Field1 = cainome.UintFromFelt(data[offset])
	offset++

	// Array field F8: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of F8")
	}
	lengthF8 := cainome.UintFromFelt(data[offset])
	offset++
	s.F8 = make([]uint8, lengthF8)
	for i := uint64(0); i < lengthF8; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of F8", i)
		}
		s.F8[i] = uint8(cainome.UintFromFelt(data[offset]))
		offset++
	}

	// Array field F9: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of F9")
	}
	lengthF9 := cainome.UintFromFelt(data[offset])
	offset++
	s.F9 = make([]*big.Int, lengthF9)
	for i := uint64(0); i < lengthF9; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of F9", i)
		}
		s.F9[i] = cainome.BigIntFromFelt(data[offset])
		offset++
	}

	return nil
}

// CairoSize returns the serialized size for GenPlainStruct
func (s *GenPlainStruct) CairoSize() int {
	return -1 // Dynamic size
}


// GenGenEvent represents a contract event
type GenGenEvent interface {
	IsGenGenEvent() bool
}

const (
	GenGenEvent_E1 = "E1"
)


// GenMyEnum represents a Cairo enum type
type GenMyEnum interface {
	IsGenMyEnum() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	GenMyEnum_Eight = "Eight"
	GenMyEnum_Eleven = "Eleven"
	GenMyEnum_Five = "Five"
	GenMyEnum_Four = "Four"
	GenMyEnum_Nine = "Nine"
	GenMyEnum_One = "One"
	GenMyEnum_Seven = "Seven"
	GenMyEnum_Six = "Six"
	GenMyEnum_Ten = "Ten"
	GenMyEnum_Three = "Three"
	GenMyEnum_Two = "Two"
)

type GenMyEnumEight struct {
	Data int64 `json:"data"`
}

func NewGenMyEnumEight(data int64) GenMyEnumEight {
	return GenMyEnumEight {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (e GenMyEnumEight) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumEight to Cairo felt array
func (g *GenMyEnumEight) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(7))
	result = append(result, cainome.FeltFromInt(int64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumEight from Cairo felt array
func (g *GenMyEnumEight) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 7 {
		return fmt.Errorf("expected discriminant 7, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = int64(cainome.IntFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumEight
func (g *GenMyEnumEight) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumEleven struct {
	Data struct {
	Field0 *felt.Felt
	Field1 uint8
	Field2 *big.Int
} `json:"data"`
}

func NewGenMyEnumEleven(data struct {
	Field0 *felt.Felt
	Field1 uint8
	Field2 *big.Int
}) GenMyEnumEleven {
	return GenMyEnumEleven {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (e GenMyEnumEleven) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumEleven to Cairo felt array
func (g *GenMyEnumEleven) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(10))
	result = append(result, g.Data.Field0)
	result = append(result, cainome.FeltFromUint(uint64(g.Data.Field1)))
	result = append(result, cainome.FeltFromBigInt(g.Data.Field2))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumEleven from Cairo felt array
func (g *GenMyEnumEleven) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 10 {
		return fmt.Errorf("expected discriminant 10, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 0")
	}
	g.Data.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 1")
	}
	g.Data.Field1 = uint8(cainome.UintFromFelt(data[offset]))
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 2")
	}
	g.Data.Field2 = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumEleven
func (g *GenMyEnumEleven) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumFive struct {
	Data *big.Int `json:"data"`
}

func NewGenMyEnumFive(data *big.Int) GenMyEnumFive {
	return GenMyEnumFive {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (f GenMyEnumFive) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumFive to Cairo felt array
func (g *GenMyEnumFive) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(4))
	result = append(result, cainome.FeltFromBigInt(g.Data))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumFive from Cairo felt array
func (g *GenMyEnumFive) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 4 {
		return fmt.Errorf("expected discriminant 4, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumFive
func (g *GenMyEnumFive) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumFour struct {
	Data uint64 `json:"data"`
}

func NewGenMyEnumFour(data uint64) GenMyEnumFour {
	return GenMyEnumFour {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (f GenMyEnumFour) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumFour to Cairo felt array
func (g *GenMyEnumFour) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(3))
	result = append(result, cainome.FeltFromUint(uint64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumFour from Cairo felt array
func (g *GenMyEnumFour) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 3 {
		return fmt.Errorf("expected discriminant 3, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = uint64(cainome.UintFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumFour
func (g *GenMyEnumFour) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumNine struct {
	Data *big.Int `json:"data"`
}

func NewGenMyEnumNine(data *big.Int) GenMyEnumNine {
	return GenMyEnumNine {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (n GenMyEnumNine) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumNine to Cairo felt array
func (g *GenMyEnumNine) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(8))
	result = append(result, cainome.FeltFromBigInt(g.Data))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumNine from Cairo felt array
func (g *GenMyEnumNine) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 8 {
		return fmt.Errorf("expected discriminant 8, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumNine
func (g *GenMyEnumNine) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumOne struct {
	Data uint8 `json:"data"`
}

func NewGenMyEnumOne(data uint8) GenMyEnumOne {
	return GenMyEnumOne {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (o GenMyEnumOne) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumOne to Cairo felt array
func (g *GenMyEnumOne) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	result = append(result, cainome.FeltFromUint(uint64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumOne from Cairo felt array
func (g *GenMyEnumOne) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = uint8(cainome.UintFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumOne
func (g *GenMyEnumOne) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumSeven struct {
	Data int32 `json:"data"`
}

func NewGenMyEnumSeven(data int32) GenMyEnumSeven {
	return GenMyEnumSeven {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (s GenMyEnumSeven) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumSeven to Cairo felt array
func (g *GenMyEnumSeven) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(6))
	result = append(result, cainome.FeltFromInt(int64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumSeven from Cairo felt array
func (g *GenMyEnumSeven) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 6 {
		return fmt.Errorf("expected discriminant 6, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = int32(cainome.IntFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumSeven
func (g *GenMyEnumSeven) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumSix struct {
	Data *felt.Felt `json:"data"`
}

func NewGenMyEnumSix(data *felt.Felt) GenMyEnumSix {
	return GenMyEnumSix {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (s GenMyEnumSix) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumSix to Cairo felt array
func (g *GenMyEnumSix) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(5))
	result = append(result, g.Data)

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumSix from Cairo felt array
func (g *GenMyEnumSix) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 5 {
		return fmt.Errorf("expected discriminant 5, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = data[offset]
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumSix
func (g *GenMyEnumSix) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumTen struct {
	Data struct {
	Field0 uint8
	Field1 *big.Int
} `json:"data"`
}

func NewGenMyEnumTen(data struct {
	Field0 uint8
	Field1 *big.Int
}) GenMyEnumTen {
	return GenMyEnumTen {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (t GenMyEnumTen) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumTen to Cairo felt array
func (g *GenMyEnumTen) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(9))
	result = append(result, cainome.FeltFromUint(uint64(g.Data.Field0)))
	result = append(result, cainome.FeltFromBigInt(g.Data.Field1))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumTen from Cairo felt array
func (g *GenMyEnumTen) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 9 {
		return fmt.Errorf("expected discriminant 9, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 0")
	}
	g.Data.Field0 = uint8(cainome.UintFromFelt(data[offset]))
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field 1")
	}
	g.Data.Field1 = cainome.BigIntFromFelt(data[offset])
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumTen
func (g *GenMyEnumTen) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumThree struct {
	Data uint32 `json:"data"`
}

func NewGenMyEnumThree(data uint32) GenMyEnumThree {
	return GenMyEnumThree {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (t GenMyEnumThree) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumThree to Cairo felt array
func (g *GenMyEnumThree) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(2))
	result = append(result, cainome.FeltFromUint(uint64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumThree from Cairo felt array
func (g *GenMyEnumThree) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 2 {
		return fmt.Errorf("expected discriminant 2, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = uint32(cainome.UintFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumThree
func (g *GenMyEnumThree) CairoSize() int {
	return -1 // Dynamic size
}

type GenMyEnumTwo struct {
	Data uint16 `json:"data"`
}

func NewGenMyEnumTwo(data uint16) GenMyEnumTwo {
	return GenMyEnumTwo {Data: data}
}

// IsGenMyEnum implements the GenMyEnum interface
func (t GenMyEnumTwo) IsGenMyEnum() bool {
	return true
}

// MarshalCairo serializes GenMyEnumTwo to Cairo felt array
func (g *GenMyEnumTwo) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	result = append(result, cainome.FeltFromUint(uint64(g.Data)))

	return result, nil
}

// UnmarshalCairo deserializes GenMyEnumTwo from Cairo felt array
func (g *GenMyEnumTwo) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for variant data")
	}
	g.Data = uint16(cainome.UintFromFelt(data[offset]))
	offset++
	return nil
}

// CairoSize returns the serialized size for GenMyEnumTwo
func (g *GenMyEnumTwo) CairoSize() int {
	return -1 // Dynamic size
}

// UnmarshalGenMyEnumFromCairo deserializes GenMyEnum from Cairo felt array
func UnmarshalGenMyEnumFromCairo(data []*felt.Felt) (GenMyEnum, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("empty data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])

	switch discriminant {
	case 7:
		var result GenMyEnumEight
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 10:
		var result GenMyEnumEleven
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 4:
		var result GenMyEnumFive
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 3:
		var result GenMyEnumFour
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 8:
		var result GenMyEnumNine
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 0:
		var result GenMyEnumOne
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 6:
		var result GenMyEnumSeven
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 5:
		var result GenMyEnumSix
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 9:
		var result GenMyEnumTen
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 2:
		var result GenMyEnumThree
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	case 1:
		var result GenMyEnumTwo
		if err := result.UnmarshalCairo(data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variant: %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("unknown enum discriminant: %d", discriminant)
	}
}


type GenContract struct {
	contractAddress *felt.Felt
}

func NewGenContract(contractAddress *felt.Felt) *GenContract {
	return &GenContract {
		contractAddress: contractAddress,
	}
}

type GenReader struct {
	*GenContract
	provider rpc.RpcProvider
}

type GenWriter struct {
	*GenContract
	account *account.Account
}

type Gen struct {
	*GenReader
	*GenWriter
}

func NewGenReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *GenReader {
	return &GenReader {
		GenContract: NewGenContract(contractAddress),
		provider: provider,
	}
}

func NewGenWriter(contractAddress *felt.Felt, account *account.Account) *GenWriter {
	return &GenWriter {
		GenContract: NewGenContract(contractAddress),
		account: account,
	}
}

func NewGen(contractAddress *felt.Felt, account *account.Account) *Gen {
	return &Gen {
		GenReader: NewGenReader(contractAddress, account.Provider),
		GenWriter: NewGenWriter(contractAddress, account),
	}
}

type GenFunc1Input struct {
	A *GenMyStructGen `json:"a"`
}

func NewGenFunc1Input(a *GenMyStructGen) *GenFunc1Input {
	return &GenFunc1Input {
		A: a,
	}
}

// MarshalCairo serializes GenFunc1Input to Cairo felt array
func (s *GenFunc1Input) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if A_data, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, A_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes GenFunc1Input from Cairo felt array
func (s *GenFunc1Input) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Pointer field A: initialize and unmarshal
	if s.A == nil {
		s.A = &GenMyStructGen{}
	}
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for GenFunc1Input
func (s *GenFunc1Input) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc1Response struct {
	// This function has no return values
}

func NewGenFunc1Response() *GenFunc1Response {
	return &GenFunc1Response{}
}

// MarshalCairo serializes GenFunc1Response to Cairo felt array
func (s *GenFunc1Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes GenFunc1Response from Cairo felt array
func (s *GenFunc1Response) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for GenFunc1Response
func (s *GenFunc1Response) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc2Input struct {
	A *GenMyStructGen `json:"a"`
}

func NewGenFunc2Input(a *GenMyStructGen) *GenFunc2Input {
	return &GenFunc2Input {
		A: a,
	}
}

// MarshalCairo serializes GenFunc2Input to Cairo felt array
func (s *GenFunc2Input) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if A_data, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, A_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes GenFunc2Input from Cairo felt array
func (s *GenFunc2Input) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Pointer field A: initialize and unmarshal
	if s.A == nil {
		s.A = &GenMyStructGen{}
	}
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for GenFunc2Input
func (s *GenFunc2Input) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc2Response struct {
	// This function has no return values
}

func NewGenFunc2Response() *GenFunc2Response {
	return &GenFunc2Response{}
}

// MarshalCairo serializes GenFunc2Response to Cairo felt array
func (s *GenFunc2Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes GenFunc2Response from Cairo felt array
func (s *GenFunc2Response) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for GenFunc2Response
func (s *GenFunc2Response) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc3Input struct {
	A *GenPlainStruct `json:"a"`
}

func NewGenFunc3Input(a *GenPlainStruct) *GenFunc3Input {
	return &GenFunc3Input {
		A: a,
	}
}

// MarshalCairo serializes GenFunc3Input to Cairo felt array
func (s *GenFunc3Input) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if A_data, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, A_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes GenFunc3Input from Cairo felt array
func (s *GenFunc3Input) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Pointer field A: initialize and unmarshal
	if s.A == nil {
		s.A = &GenPlainStruct{}
	}
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for GenFunc3Input
func (s *GenFunc3Input) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc4Input struct {
	A GenMyEnum `json:"a"`
}

func NewGenFunc4Input(a GenMyEnum) *GenFunc4Input {
	return &GenFunc4Input {
		A: a,
	}
}

// MarshalCairo serializes GenFunc4Input to Cairo felt array
func (s *GenFunc4Input) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if A_data, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, A_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes GenFunc4Input from Cairo felt array
func (s *GenFunc4Input) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Complex field A: unmarshal using CairoMarshaler
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for GenFunc4Input
func (s *GenFunc4Input) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc5Input struct {
	A *GenMyStructInnerGeneric `json:"a"`
}

func NewGenFunc5Input(a *GenMyStructInnerGeneric) *GenFunc5Input {
	return &GenFunc5Input {
		A: a,
	}
}

// MarshalCairo serializes GenFunc5Input to Cairo felt array
func (s *GenFunc5Input) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	if A_data, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, A_data...)
	}

	return result, nil
}

// UnmarshalCairo deserializes GenFunc5Input from Cairo felt array
func (s *GenFunc5Input) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Pointer field A: initialize and unmarshal
	if s.A == nil {
		s.A = &GenMyStructInnerGeneric{}
	}
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data


	return nil
}

// CairoSize returns the serialized size for GenFunc5Input
func (s *GenFunc5Input) CairoSize() int {
	return -1 // Dynamic size
}

type GenFunc5Response struct {
	// This function has no return values
}

func NewGenFunc5Response() *GenFunc5Response {
	return &GenFunc5Response{}
}

// MarshalCairo serializes GenFunc5Response to Cairo felt array
func (s *GenFunc5Response) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes GenFunc5Response from Cairo felt array
func (s *GenFunc5Response) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for GenFunc5Response
func (s *GenFunc5Response) CairoSize() int {
	return -1 // Dynamic size
}

type GenReadResponse struct {
	Value struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
} `json:"value"`
}

func NewGenReadResponse(value struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}) *GenReadResponse {
	return &GenReadResponse {
		Value: value,
	}
}

// MarshalCairo serializes GenReadResponse to Cairo felt array
func (s *GenReadResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Tuple field Value: marshal each sub-field (tuple has 2 elements)
	result = append(result, s.Value.Field0)
	result = append(result, s.Value.Field1)

	return result, nil
}

// UnmarshalCairo deserializes GenReadResponse from Cairo felt array
func (s *GenReadResponse) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Tuple field Value: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Value element 0")
	}
	s.Value.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Value element 1")
	}
	s.Value.Field1 = data[offset]
	offset++


	return nil
}

// CairoSize returns the serialized size for GenReadResponse
func (s *GenReadResponse) CairoSize() int {
	return -1 // Dynamic size
}

func (gen_contract *GenContract) Func1(input *GenFunc1Input) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func1"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func1Legacy(a *GenMyStructGen) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, a_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func1"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func2(input *GenFunc2Input) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func2"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func2Legacy(a *GenMyStructGen) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, a_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func2"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func3(input *GenFunc3Input) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func3"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func3Legacy(a *GenPlainStruct) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, a_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func3"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func4(input *GenFunc4Input) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func4"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func4Legacy(a GenMyEnum) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, a_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func4"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func5(input *GenFunc5Input) (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata, err := input.MarshalCairo()
	if err != nil {
		return rpc.FunctionCall{}, err
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func5"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Func5Legacy(a *GenMyStructInnerGeneric) (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return rpc.FunctionCall{}, err
	} else {
		calldata = append(calldata, a_data...)
	}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("func5"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) Read() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("read"),
		Calldata:           calldata,
	}, nil
}

func (gen_contract *GenContract) ReadLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    gen_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("read"),
		Calldata:           calldata,
	}, nil
}

func (gen_writer *GenWriter) Func1(ctx context.Context, a *GenMyStructGen, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal a: %w", err)
	} else {
		calldata = append(calldata, a_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, gen_writer.account, gen_writer.contractAddress, utils.GetSelectorFromNameFelt("func1"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (gen_writer *GenWriter) Func2(ctx context.Context, a *GenMyStructGen, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal a: %w", err)
	} else {
		calldata = append(calldata, a_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, gen_writer.account, gen_writer.contractAddress, utils.GetSelectorFromNameFelt("func2"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (gen_reader *GenReader) Func3(ctx context.Context, a *GenPlainStruct, opts *cainome.CallOpts) error {
	return nil
}

func (gen_reader *GenReader) Func4(ctx context.Context, a GenMyEnum, opts *cainome.CallOpts) error {
	return nil
}

func (gen_writer *GenWriter) Func5(ctx context.Context, a *GenMyStructInnerGeneric, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if a_data, err := a.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal a: %w", err)
	} else {
		calldata = append(calldata, a_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, gen_writer.account, gen_writer.contractAddress, utils.GetSelectorFromNameFelt("func5"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (gen_reader *GenReader) Read(ctx context.Context, opts *cainome.CallOpts) (struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    gen_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("read"),
		Calldata:           calldata,
	}

	response, err := gen_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}{}, fmt.Errorf("empty response")
	}
	var result struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}
	offset := 0

	if offset >= len(response) {
		return struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}{}, fmt.Errorf("insufficient data for tuple field 0")
	}
	result.Field0 = response[offset]
	offset++

	if offset >= len(response) {
		return struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
}{}, fmt.Errorf("insufficient data for tuple field 1")
	}
	result.Field1 = response[offset]
	offset++

	return result, nil
}

