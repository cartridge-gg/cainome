// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/cartridge-gg/cainome"
	"math/big"
	"github.com/NethermindEth/starknet.go/utils"
)

type EventNothing struct {
}

// MarshalCairo serializes EventNothing to Cairo felt array
func (s *EventNothing) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	return result, nil
}

// UnmarshalCairo deserializes EventNothing from Cairo felt array
func (s *EventNothing) UnmarshalCairo(data []*felt.Felt) error {
	return nil
}

// CairoSize returns the serialized size for EventNothing
func (s *EventNothing) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventNothing) EventName() string {
	return "nothing"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventNothing) IsSimpleEventsEvent() bool {
	return true
}


type EventOnlyData struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventOnlyData to Cairo felt array
func (s *EventOnlyData) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventOnlyData from Cairo felt array
func (s *EventOnlyData) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventOnlyData
func (s *EventOnlyData) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventOnlyData) EventName() string {
	return "only_data"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventOnlyData) IsSimpleEventsEvent() bool {
	return true
}


// SimpleEventsEvent represents a contract event
type SimpleEventsEvent interface {
	IsSimpleEventsEvent() bool
}

const (
	SimpleEventsEvent_EventOnlyKey = "EventOnlyKey"
	SimpleEventsEvent_EventOnlyData = "EventOnlyData"
	SimpleEventsEvent_EventAll = "EventAll"
	SimpleEventsEvent_EventMultiple = "EventMultiple"
	SimpleEventsEvent_EventNothing = "EventNothing"
	SimpleEventsEvent_SuperEvent = "SuperEvent"
)


type EventAll struct {
	Header *felt.Felt `json:"header"`
	Value []*felt.Felt `json:"value"`
}

// MarshalCairo serializes EventAll to Cairo felt array
func (s *EventAll) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Header)
	// Array field Value: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Value))))
	for _, item := range s.Value {
		result = append(result, item)
	}
	return result, nil
}

// UnmarshalCairo deserializes EventAll from Cairo felt array
func (s *EventAll) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Header")
	}
	s.Header = data[offset]
	offset++

	// Array field Value: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Value")
	}
	lengthValue := cainome.UintFromFelt(data[offset])
	offset++
	s.Value = make([]*felt.Felt, lengthValue)
	for i := uint64(0); i < lengthValue; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of Value", i)
		}
		s.Value[i] = data[offset]
		offset++
	}

	return nil
}

// CairoSize returns the serialized size for EventAll
func (s *EventAll) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventAll) EventName() string {
	return "all"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventAll) IsSimpleEventsEvent() bool {
	return true
}


type EventMultiple struct {
	Key1 *felt.Felt `json:"key1"`
	Key2 *felt.Felt `json:"key2"`
	Data1 *felt.Felt `json:"data1"`
	Data2 *big.Int `json:"data2"`
	Data3 struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
} `json:"data3"`
}

// MarshalCairo serializes EventMultiple to Cairo felt array
func (s *EventMultiple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Key1)
	result = append(result, s.Key2)
	result = append(result, s.Data1)
	result = append(result, cainome.FeltFromBigInt(s.Data2))
	// Tuple field Data3: marshal each sub-field
	result = append(result, s.Data3.Field0)
	result = append(result, s.Data3.Field1)
	return result, nil
}

// UnmarshalCairo deserializes EventMultiple from Cairo felt array
func (s *EventMultiple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Key1")
	}
	s.Key1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Key2")
	}
	s.Key2 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data1")
	}
	s.Data1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data2")
	}
	s.Data2 = cainome.BigIntFromFelt(data[offset])
	offset++

	// Tuple field Data3: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Data3 element 0")
	}
	s.Data3.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Data3 element 1")
	}
	s.Data3.Field1 = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventMultiple
func (s *EventMultiple) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventMultiple) EventName() string {
	return "multiple"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventMultiple) IsSimpleEventsEvent() bool {
	return true
}


type EventWithOtherName struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventWithOtherName to Cairo felt array
func (s *EventWithOtherName) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventWithOtherName from Cairo felt array
func (s *EventWithOtherName) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventWithOtherName
func (s *EventWithOtherName) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventWithOtherName) EventName() string {
	return "with_other_name"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventWithOtherName) IsSimpleEventsEvent() bool {
	return true
}


type EventOnlyKey struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventOnlyKey to Cairo felt array
func (s *EventOnlyKey) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventOnlyKey from Cairo felt array
func (s *EventOnlyKey) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventOnlyKey
func (s *EventOnlyKey) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventOnlyKey) EventName() string {
	return "only_key"
}

// IsSimpleEventsEvent implements the SimpleEventsEvent interface
func (e EventOnlyKey) IsSimpleEventsEvent() bool {
	return true
}


type EventsReader struct {
	contractAddress *felt.Felt
	provider rpc.RpcProvider
}

type EventsWriter struct {
	contractAddress *felt.Felt
	account *account.Account
}

type Events struct {
	*EventsReader
	*EventsWriter
}

func NewEventsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *EventsReader {
	return &EventsReader {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func NewEventsWriter(contractAddress *felt.Felt, account *account.Account) *EventsWriter {
	return &EventsWriter {
		contractAddress: contractAddress,
		account: account,
	}
}

func NewEvents(contractAddress *felt.Felt, account *account.Account) *Events {
	return &Events {
		EventsReader: NewEventsReader(contractAddress, account.Provider),
		EventsWriter: NewEventsWriter(contractAddress, account),
	}
}

func (events_writer *EventsWriter) EmitOnlyKey(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_only_key"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitOnlyData(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_only_data"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitAll(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_all"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitMultiple(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_multiple"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitNothing(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_nothing"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitSuper(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_super"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

