// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/cartridge-gg/cainome"
	"math/big"
)

type EventsEventAll struct {
	Header *felt.Felt `json:"header"`
	Value []*felt.Felt `json:"value"`
}

// MarshalCairo serializes EventsEventAll to Cairo felt array
func (s *EventsEventAll) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Header)
	// Array field Value: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Value))))
	for _, item := range s.Value {
		result = append(result, item)
	}
	return result, nil
}

// UnmarshalCairo deserializes EventsEventAll from Cairo felt array
func (s *EventsEventAll) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Header")
	}
	s.Header = data[offset]
	offset++

	// Array field Value: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Value")
	}
	lengthValue := cainome.UintFromFelt(data[offset])
	offset++
	s.Value = make([]*felt.Felt, lengthValue)
	for i := uint64(0); i < lengthValue; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of Value", i)
		}
		s.Value[i] = data[offset]
		offset++
	}

	return nil
}

// CairoSize returns the serialized size for EventsEventAll
func (s *EventsEventAll) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventAll) EventName() string {
	return "s_all"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventAll) IsEventsSimpleEventsEvent() bool {
	return true
}


type EventsEventMultiple struct {
	Data1 *felt.Felt `json:"data1"`
	Data2 *big.Int `json:"data2"`
	Data3 struct {
	Field0 *felt.Felt
	Field1 *felt.Felt
} `json:"data3"`
	Key1 *felt.Felt `json:"key1"`
	Key2 *felt.Felt `json:"key2"`
}

// MarshalCairo serializes EventsEventMultiple to Cairo felt array
func (s *EventsEventMultiple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Data1)
	result = append(result, cainome.FeltFromBigInt(s.Data2))
	// Tuple field Data3: marshal each sub-field (tuple has 2 elements)
	result = append(result, s.Data3.Field0)
	result = append(result, s.Data3.Field1)
	result = append(result, s.Key1)
	result = append(result, s.Key2)
	return result, nil
}

// UnmarshalCairo deserializes EventsEventMultiple from Cairo felt array
func (s *EventsEventMultiple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data1")
	}
	s.Data1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data2")
	}
	s.Data2 = cainome.BigIntFromFelt(data[offset])
	offset++

	// Tuple field Data3: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Data3 element 0")
	}
	s.Data3.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Data3 element 1")
	}
	s.Data3.Field1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Key1")
	}
	s.Key1 = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Key2")
	}
	s.Key2 = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventsEventMultiple
func (s *EventsEventMultiple) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventMultiple) EventName() string {
	return "s_multiple"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventMultiple) IsEventsSimpleEventsEvent() bool {
	return true
}


type EventsEventNothing struct {
}

// MarshalCairo serializes EventsEventNothing to Cairo felt array
func (s *EventsEventNothing) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	return result, nil
}

// UnmarshalCairo deserializes EventsEventNothing from Cairo felt array
func (s *EventsEventNothing) UnmarshalCairo(data []*felt.Felt) error {
	return nil
}

// CairoSize returns the serialized size for EventsEventNothing
func (s *EventsEventNothing) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventNothing) EventName() string {
	return "s_nothing"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventNothing) IsEventsSimpleEventsEvent() bool {
	return true
}


type EventsEventOnlyData struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventsEventOnlyData to Cairo felt array
func (s *EventsEventOnlyData) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventsEventOnlyData from Cairo felt array
func (s *EventsEventOnlyData) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventsEventOnlyData
func (s *EventsEventOnlyData) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventOnlyData) EventName() string {
	return "s_only_data"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventOnlyData) IsEventsSimpleEventsEvent() bool {
	return true
}


type EventsEventOnlyKey struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventsEventOnlyKey to Cairo felt array
func (s *EventsEventOnlyKey) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventsEventOnlyKey from Cairo felt array
func (s *EventsEventOnlyKey) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventsEventOnlyKey
func (s *EventsEventOnlyKey) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventOnlyKey) EventName() string {
	return "s_only_key"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventOnlyKey) IsEventsSimpleEventsEvent() bool {
	return true
}


type EventsEventWithOtherName struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes EventsEventWithOtherName to Cairo felt array
func (s *EventsEventWithOtherName) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes EventsEventWithOtherName from Cairo felt array
func (s *EventsEventWithOtherName) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for EventsEventWithOtherName
func (s *EventsEventWithOtherName) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e EventsEventWithOtherName) EventName() string {
	return "s_with_other_name"
}

// IsEventsSimpleEventsEvent implements the EventsSimpleEventsEvent interface
func (e EventsEventWithOtherName) IsEventsSimpleEventsEvent() bool {
	return true
}


// EventsSimpleEventsEvent represents a contract event
type EventsSimpleEventsEvent interface {
	IsEventsSimpleEventsEvent() bool
}

const (
	EventsSimpleEventsEvent_EventAll = "EventAll"
	EventsSimpleEventsEvent_EventMultiple = "EventMultiple"
	EventsSimpleEventsEvent_EventNothing = "EventNothing"
	EventsSimpleEventsEvent_EventOnlyData = "EventOnlyData"
	EventsSimpleEventsEvent_EventOnlyKey = "EventOnlyKey"
	EventsSimpleEventsEvent_SuperEvent = "SuperEvent"
)


type EventsContract struct {
	contractAddress *felt.Felt
}

func NewEventsContract(contractAddress *felt.Felt) *EventsContract {
	return &EventsContract {
		contractAddress: contractAddress,
	}
}

type EventsReader struct {
	*EventsContract
	provider rpc.RpcProvider
}

type EventsWriter struct {
	*EventsContract
	account *account.Account
}

type Events struct {
	*EventsReader
	*EventsWriter
}

func NewEventsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *EventsReader {
	return &EventsReader {
		EventsContract: NewEventsContract(contractAddress),
		provider: provider,
	}
}

func NewEventsWriter(contractAddress *felt.Felt, account *account.Account) *EventsWriter {
	return &EventsWriter {
		EventsContract: NewEventsContract(contractAddress),
		account: account,
	}
}

func NewEvents(contractAddress *felt.Felt, account *account.Account) *Events {
	return &Events {
		EventsReader: NewEventsReader(contractAddress, account.Provider),
		EventsWriter: NewEventsWriter(contractAddress, account),
	}
}

type EventsEmitAllResponse struct {
	// This function has no return values
}

func NewEventsEmitAllResponse() *EventsEmitAllResponse {
	return &EventsEmitAllResponse{}
}

// MarshalCairo serializes EventsEmitAllResponse to Cairo felt array
func (s *EventsEmitAllResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitAllResponse from Cairo felt array
func (s *EventsEmitAllResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitAllResponse
func (s *EventsEmitAllResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EventsEmitMultipleResponse struct {
	// This function has no return values
}

func NewEventsEmitMultipleResponse() *EventsEmitMultipleResponse {
	return &EventsEmitMultipleResponse{}
}

// MarshalCairo serializes EventsEmitMultipleResponse to Cairo felt array
func (s *EventsEmitMultipleResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitMultipleResponse from Cairo felt array
func (s *EventsEmitMultipleResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitMultipleResponse
func (s *EventsEmitMultipleResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EventsEmitNothingResponse struct {
	// This function has no return values
}

func NewEventsEmitNothingResponse() *EventsEmitNothingResponse {
	return &EventsEmitNothingResponse{}
}

// MarshalCairo serializes EventsEmitNothingResponse to Cairo felt array
func (s *EventsEmitNothingResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitNothingResponse from Cairo felt array
func (s *EventsEmitNothingResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitNothingResponse
func (s *EventsEmitNothingResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EventsEmitOnlyDataResponse struct {
	// This function has no return values
}

func NewEventsEmitOnlyDataResponse() *EventsEmitOnlyDataResponse {
	return &EventsEmitOnlyDataResponse{}
}

// MarshalCairo serializes EventsEmitOnlyDataResponse to Cairo felt array
func (s *EventsEmitOnlyDataResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitOnlyDataResponse from Cairo felt array
func (s *EventsEmitOnlyDataResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitOnlyDataResponse
func (s *EventsEmitOnlyDataResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EventsEmitOnlyKeyResponse struct {
	// This function has no return values
}

func NewEventsEmitOnlyKeyResponse() *EventsEmitOnlyKeyResponse {
	return &EventsEmitOnlyKeyResponse{}
}

// MarshalCairo serializes EventsEmitOnlyKeyResponse to Cairo felt array
func (s *EventsEmitOnlyKeyResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitOnlyKeyResponse from Cairo felt array
func (s *EventsEmitOnlyKeyResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitOnlyKeyResponse
func (s *EventsEmitOnlyKeyResponse) CairoSize() int {
	return -1 // Dynamic size
}

type EventsEmitSuperResponse struct {
	// This function has no return values
}

func NewEventsEmitSuperResponse() *EventsEmitSuperResponse {
	return &EventsEmitSuperResponse{}
}

// MarshalCairo serializes EventsEmitSuperResponse to Cairo felt array
func (s *EventsEmitSuperResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes EventsEmitSuperResponse from Cairo felt array
func (s *EventsEmitSuperResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for EventsEmitSuperResponse
func (s *EventsEmitSuperResponse) CairoSize() int {
	return -1 // Dynamic size
}

func (events_contract *EventsContract) EmitAll() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_all"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitAllLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_all"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitMultiple() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_multiple"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitMultipleLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_multiple"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitNothing() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_nothing"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitNothingLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_nothing"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitOnlyData() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_only_data"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitOnlyDataLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_only_data"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitOnlyKey() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_only_key"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitOnlyKeyLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_only_key"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitSuper() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_super"),
		Calldata:           calldata,
	}, nil
}

func (events_contract *EventsContract) EmitSuperLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_super"),
		Calldata:           calldata,
	}, nil
}

func (events_writer *EventsWriter) EmitAll(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_all"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitMultiple(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_multiple"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitNothing(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_nothing"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitOnlyData(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_only_data"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitOnlyKey(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_only_key"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (events_writer *EventsWriter) EmitSuper(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, events_writer.account, events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_super"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

