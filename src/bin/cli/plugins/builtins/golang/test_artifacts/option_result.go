// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/cartridge-gg/cainome"
	"math/big"
	"github.com/NethermindEth/starknet.go/utils"
)

// OptionResultEvent represents a contract event
type OptionResultEvent interface {
	IsOptionResultEvent() bool
}


type GenericOneOptionResult struct {
	A *felt.Felt `json:"a"`
	B *felt.Felt `json:"b"`
	C *big.Int `json:"c"`
}

// MarshalCairo serializes GenericOneOptionResult to Cairo felt array
func (s *GenericOneOptionResult) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.A)
	result = append(result, s.B)
	result = append(result, cainome.FeltFromBigInt(s.C))
	return result, nil
}

// UnmarshalCairo deserializes GenericOneOptionResult from Cairo felt array
func (s *GenericOneOptionResult) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field C")
	}
	s.C = cainome.BigIntFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for GenericOneOptionResult
func (s *GenericOneOptionResult) CairoSize() int {
	return -1 // Dynamic size
}


type OptionResultReader struct {
	contractAddress *felt.Felt
	provider rpc.RpcProvider
}

type OptionResultWriter struct {
	contractAddress *felt.Felt
	account *account.Account
}

type OptionResult struct {
	*OptionResultReader
	*OptionResultWriter
}

func NewOptionResultReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *OptionResultReader {
	return &OptionResultReader {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func NewOptionResultWriter(contractAddress *felt.Felt, account *account.Account) *OptionResultWriter {
	return &OptionResultWriter {
		contractAddress: contractAddress,
		account: account,
	}
}

func NewOptionResult(contractAddress *felt.Felt, account *account.Account) *OptionResult {
	return &OptionResult {
		OptionResultReader: NewOptionResultReader(contractAddress, account.Provider),
		OptionResultWriter: NewOptionResultWriter(contractAddress, account),
	}
}

func (option_result_reader *OptionResultReader) ResultOkUnit(ctx context.Context, res cainome.Result[struct{}, *felt.Felt], opts *cainome.CallOpts) (cainome.Result[uint64, *felt.Felt], error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if res_data, err := res.MarshalCairo(); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	} else {
		calldata = append(calldata, res_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("result_ok_unit"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("empty response")
	}
	var result cainome.Result[uint64, *felt.Felt]
	if err := result.UnmarshalCairo(response); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (option_result_reader *OptionResultReader) ResultOkStruct(ctx context.Context, res cainome.Result[*GenericOneOptionResult, *felt.Felt], opts *cainome.CallOpts) (cainome.Result[uint64, *felt.Felt], error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if res_data, err := res.MarshalCairo(); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	} else {
		calldata = append(calldata, res_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("result_ok_struct"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("empty response")
	}
	var result cainome.Result[uint64, *felt.Felt]
	if err := result.UnmarshalCairo(response); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (option_result_reader *OptionResultReader) ResultOkTupleStruct(ctx context.Context, res cainome.Result[struct {
	Field0 *GenericOneOptionResult
	Field1 *felt.Felt
}, *felt.Felt], opts *cainome.CallOpts) (cainome.Result[uint64, *felt.Felt], error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if res_data, err := res.MarshalCairo(); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	} else {
		calldata = append(calldata, res_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("result_ok_tuple_struct"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("empty response")
	}
	var result cainome.Result[uint64, *felt.Felt]
	if err := result.UnmarshalCairo(response); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (option_result_reader *OptionResultReader) ResultOk(ctx context.Context, res cainome.Result[*felt.Felt, *big.Int], opts *cainome.CallOpts) (cainome.Result[uint64, *felt.Felt], error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if res_data, err := res.MarshalCairo(); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	} else {
		calldata = append(calldata, res_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("result_ok"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("empty response")
	}
	var result cainome.Result[uint64, *felt.Felt]
	if err := result.UnmarshalCairo(response); err != nil {
		return cainome.Result[uint64, *felt.Felt]{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (option_result_reader *OptionResultReader) ResultErr(ctx context.Context, res cainome.Result[*felt.Felt, *felt.Felt], opts *cainome.CallOpts) (cainome.Result[*felt.Felt, *big.Int], error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if res_data, err := res.MarshalCairo(); err != nil {
		return cainome.Result[*felt.Felt, *big.Int]{}, err
	} else {
		calldata = append(calldata, res_data...)
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("result_err"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return cainome.Result[*felt.Felt, *big.Int]{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return cainome.Result[*felt.Felt, *big.Int]{}, fmt.Errorf("empty response")
	}
	var result cainome.Result[*felt.Felt, *big.Int]
	if err := result.UnmarshalCairo(response); err != nil {
		return cainome.Result[*felt.Felt, *big.Int]{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (option_result_reader *OptionResultReader) OptionSome(ctx context.Context, opt **felt.Felt, opts *cainome.CallOpts) (*[]*felt.Felt, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if opt != nil {
		calldata = append(calldata, cainome.FeltFromUint(1)) // Some variant
		calldata = append(calldata, *opt)
	} else {
		calldata = append(calldata, cainome.FeltFromUint(0)) // None variant
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("option_some"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	// Check Option discriminant
	if cainome.UintFromFelt(response[0]) == 0 {
		// None variant
		return nil, nil
	} else {
		// Some variant - deserialize array
		if len(response) < 2 {
			return nil, fmt.Errorf("insufficient data for Some variant")
		}
		arrayLength := cainome.UintFromFelt(response[1])
		if len(response) < int(2 + arrayLength) {
			return nil, fmt.Errorf("insufficient data for array elements")
		}
		result := make([]*felt.Felt, arrayLength)
		for i := uint64(0); i < arrayLength; i++ {
			result[i] = response[2+i]
		}
		return &result, nil
	}
}

func (option_result_reader *OptionResultReader) OptionNone(ctx context.Context, opt **felt.Felt, opts *cainome.CallOpts) (*uint64, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if opt != nil {
		calldata = append(calldata, cainome.FeltFromUint(1)) // Some variant
		calldata = append(calldata, *opt)
	} else {
		calldata = append(calldata, cainome.FeltFromUint(0)) // None variant
	}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    option_result_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("option_none"),
		Calldata:           calldata,
	}

	response, err := option_result_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	// Check Option discriminant
	if cainome.UintFromFelt(response[0]) == 0 {
		// None variant
		return nil, nil
	} else {
		// Some variant - extract value
		if len(response) < 2 {
			return nil, fmt.Errorf("insufficient data for Some variant")
		}
		var result uint64
		// TODO: Convert response[1:] to inner type
		_ = response
		return &result, nil
	}
}

