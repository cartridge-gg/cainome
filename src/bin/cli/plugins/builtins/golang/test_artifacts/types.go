// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"fmt"
	"math/big"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
)

// CallOpts contains options for contract view calls
type CallOpts struct {
	BlockID *rpc.BlockID // Optional block ID (defaults to "latest" if nil)
}

// CallOption defines a function type for setting call options
type CallOption func(*CallOpts)

// WithBlockID sets the block ID for the call
func WithBlockID(blockID rpc.BlockID) CallOption {
	return func(opts *CallOpts) {
		opts.BlockID = &blockID
	}
}

// NewCallOpts creates a new CallOpts with optional configurations
func NewCallOpts(options ...CallOption) *CallOpts {
	opts := &CallOpts{}
	for _, option := range options {
		option(opts)
	}
	return opts
}

// CairoMarshaler interface for types that can be serialized/deserialized to/from Cairo felt arrays
type CairoMarshaler interface {
	// MarshalCairo serializes the type to a Cairo felt array
	MarshalCairo() ([]*felt.Felt, error)
	
	// UnmarshalCairo deserializes the type from a Cairo felt array
	UnmarshalCairo(data []*felt.Felt) error
}

// CairoSerde provides static size information for Cairo serialization
type CairoSerde interface {
	CairoMarshaler
	
	// CairoSize returns the serialized size in felts, or -1 for dynamic size
	CairoSize() int
}

// Result type for handling Cairo Result types with idiomatic Go error handling
type Result[T, E any] struct {
	IsOk bool
	Ok   T
	Err  E
}

// NewResultOk creates a successful Result
func NewResultOk[T, E any](value T) Result[T, E] {
	return Result[T, E]{IsOk: true, Ok: value}
}

// NewResultErr creates a failed Result
func NewResultErr[T, E any](err E) Result[T, E] {
	return Result[T, E]{IsOk: false, Err: err}
}

// Unwrap returns the success value and error in idiomatic Go pattern
func (r Result[T, E]) Unwrap() (T, error) {
	if r.IsOk {
		return r.Ok, nil
	}
	var zero T
	// If E implements error interface, use it directly
	if err, ok := any(r.Err).(error); ok {
		return zero, err
	}
	// Otherwise, create a generic error
	return zero, fmt.Errorf("result error: %+v", r.Err)
}

// Helper functions for Cairo serialization

// FeltFromUint converts a uint64 to *felt.Felt
func FeltFromUint(value uint64) *felt.Felt {
	return new(felt.Felt).SetUint64(value)
}

// FeltFromBigInt converts a *big.Int to *felt.Felt
func FeltFromBigInt(value *big.Int) *felt.Felt {
	if value == nil {
		return new(felt.Felt)
	}
	result := new(felt.Felt)
	result.SetBytes(value.Bytes())
	return result
}

// FeltFromBool converts a bool to *felt.Felt (0 for false, 1 for true)
func FeltFromBool(value bool) *felt.Felt {
	if value {
		return new(felt.Felt).SetUint64(1)
	}
	return new(felt.Felt)
}

// UintFromFelt converts *felt.Felt to uint64
func UintFromFelt(f *felt.Felt) uint64 {
	if f == nil {
		return 0
	}
	return f.Uint64()
}

// BigIntFromFelt converts *felt.Felt to *big.Int
func BigIntFromFelt(f *felt.Felt) *big.Int {
	if f == nil {
		return big.NewInt(0)
	}
	return f.BigInt(big.NewInt(0))
}

// BoolFromFelt converts *felt.Felt to bool (0 is false, anything else is true)
func BoolFromFelt(f *felt.Felt) bool {
	if f == nil {
		return false
	}
	return !f.IsZero()
}

// CairoSerializeArray serializes an array with length prefix
func CairoSerializeArray(items []CairoMarshaler) ([]*felt.Felt, error) {
	result := []*felt.Felt{FeltFromUint(uint64(len(items)))}
	for _, item := range items {
		data, err := item.MarshalCairo()
		if err != nil {
			return nil, err
		}
		result = append(result, data...)
	}
	return result, nil
}

// CairoDeserializeArray deserializes an array with length prefix
func CairoDeserializeArray(data []*felt.Felt, offset int, createItem func() CairoMarshaler) ([]CairoMarshaler, int, error) {
	if len(data) <= offset {
		return nil, offset, fmt.Errorf("insufficient data for array length")
	}
	
	length := UintFromFelt(data[offset])
	offset++
	
	result := make([]CairoMarshaler, length)
	for i := uint64(0); i < length; i++ {
		item := createItem()
		if err := item.UnmarshalCairo(data[offset:]); err != nil {
			return nil, offset, err
		}
		
		// Calculate how many felts this item consumed
		itemData, err := item.MarshalCairo()
		if err != nil {
			return nil, offset, err
		}
		offset += len(itemData)
		result[i] = item
	}
	
	return result, offset, nil
}

// Basic type wrapper implementations for CairoMarshaler interface

// CairoFelt wraps *felt.Felt to implement CairoMarshaler
type CairoFelt struct {
	Value *felt.Felt
}

func (f *CairoFelt) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{f.Value}, nil
}

func (f *CairoFelt) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for felt")
	}
	f.Value = data[0]
	return nil
}

func (f *CairoFelt) CairoSize() int {
	return 1
}

// CairoUint64 wraps uint64 to implement CairoMarshaler
type CairoUint64 struct {
	Value uint64
}

func (u *CairoUint64) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromUint(u.Value)}, nil
}

func (u *CairoUint64) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for uint64")
	}
	u.Value = UintFromFelt(data[0])
	return nil
}

func (u *CairoUint64) CairoSize() int {
	return 1
}

// CairoUint32 wraps uint32 to implement CairoMarshaler
type CairoUint32 struct {
	Value uint32
}

func (u *CairoUint32) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromUint(uint64(u.Value))}, nil
}

func (u *CairoUint32) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for uint32")
	}
	u.Value = uint32(UintFromFelt(data[0]))
	return nil
}

func (u *CairoUint32) CairoSize() int {
	return 1
}

// CairoUint16 wraps uint16 to implement CairoMarshaler
type CairoUint16 struct {
	Value uint16
}

func (u *CairoUint16) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromUint(uint64(u.Value))}, nil
}

func (u *CairoUint16) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for uint16")
	}
	u.Value = uint16(UintFromFelt(data[0]))
	return nil
}

func (u *CairoUint16) CairoSize() int {
	return 1
}

// CairoUint8 wraps uint8 to implement CairoMarshaler
type CairoUint8 struct {
	Value uint8
}

func (u *CairoUint8) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromUint(uint64(u.Value))}, nil
}

func (u *CairoUint8) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for uint8")
	}
	u.Value = uint8(UintFromFelt(data[0]))
	return nil
}

func (u *CairoUint8) CairoSize() int {
	return 1
}

// CairoBigInt wraps *big.Int to implement CairoMarshaler  
type CairoBigInt struct {
	Value *big.Int
}

func (b *CairoBigInt) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromBigInt(b.Value)}, nil
}

func (b *CairoBigInt) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for big.Int")
	}
	b.Value = BigIntFromFelt(data[0])
	return nil
}

func (b *CairoBigInt) CairoSize() int {
	return 1
}

// CairoBool wraps bool to implement CairoMarshaler
type CairoBool struct {
	Value bool
}

func (b *CairoBool) MarshalCairo() ([]*felt.Felt, error) {
	return []*felt.Felt{FeltFromBool(b.Value)}, nil
}

func (b *CairoBool) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for bool")
	}
	b.Value = BoolFromFelt(data[0])
	return nil
}

func (b *CairoBool) CairoSize() int {
	return 1
}

// CairoFeltArray wraps []*felt.Felt to implement CairoMarshaler with length prefix
type CairoFeltArray struct {
	Value []*felt.Felt
}

func (a *CairoFeltArray) MarshalCairo() ([]*felt.Felt, error) {
	result := []*felt.Felt{FeltFromUint(uint64(len(a.Value)))}
	result = append(result, a.Value...)
	return result, nil
}

func (a *CairoFeltArray) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for array length")
	}
	length := UintFromFelt(data[0])
	if len(data) < int(length)+1 {
		return fmt.Errorf("insufficient data for array elements")
	}
	a.Value = data[1:length+1]
	return nil
}

func (a *CairoFeltArray) CairoSize() int {
	return -1 // Dynamic size
}

