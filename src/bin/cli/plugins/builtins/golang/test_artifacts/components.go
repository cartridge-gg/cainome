// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/cartridge-gg/cainome"
	"math/big"
	"github.com/NethermindEth/starknet.go/utils"
)

type MyStructSimple struct {
	A *felt.Felt `json:"a"`
	B *felt.Felt `json:"b"`
}

// MarshalCairo serializes MyStructSimple to Cairo felt array
func (s *MyStructSimple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.A)
	result = append(result, s.B)
	return result, nil
}

// UnmarshalCairo deserializes MyStructSimple from Cairo felt array
func (s *MyStructSimple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for MyStructSimple
func (s *MyStructSimple) CairoSize() int {
	return -1 // Dynamic size
}


type OutterEvent struct {
}

// MarshalCairo serializes OutterEvent to Cairo felt array
func (s *OutterEvent) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	return result, nil
}

// UnmarshalCairo deserializes OutterEvent from Cairo felt array
func (s *OutterEvent) UnmarshalCairo(data []*felt.Felt) error {
	return nil
}

// CairoSize returns the serialized size for OutterEvent
func (s *OutterEvent) CairoSize() int {
	return -1 // Dynamic size
}


// EventName returns the name of this event type
func (e OutterEvent) EventName() string {
	return "outter"
}

// IsComponentsContractEvent implements the ComponentsContractEvent interface
func (e OutterEvent) IsComponentsContractEvent() bool {
	return true
}


// SimpleEvent represents a contract event
type SimpleEvent interface {
	IsSimpleEvent() bool
}

const (
	SimpleEvent_Written = "Written"
	SimpleEvent_Written88 = "Written88"
)


// OtherEvent represents a contract event
type OtherEvent interface {
	IsOtherEvent() bool
}

const (
	OtherEvent_Written = "Written"
)


// ComponentsContractEvent represents a contract event
type ComponentsContractEvent interface {
	IsComponentsContractEvent() bool
}

const (
	ComponentsContractEvent_OutterEvent = "OutterEvent"
	ComponentsContractEvent_SimpleEvent = "SimpleEvent"
	ComponentsContractEvent_SimpleEventOther = "SimpleEventOther"
)


type MyStructOther struct {
	Data *big.Int `json:"data"`
}

// MarshalCairo serializes MyStructOther to Cairo felt array
func (s *MyStructOther) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromBigInt(s.Data))
	return result, nil
}

// UnmarshalCairo deserializes MyStructOther from Cairo felt array
func (s *MyStructOther) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data")
	}
	s.Data = cainome.BigIntFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for MyStructOther
func (s *MyStructOther) CairoSize() int {
	return -1 // Dynamic size
}


type WrittenAb struct {
	Data *felt.Felt `json:"data"`
}

// MarshalCairo serializes WrittenAb to Cairo felt array
func (s *WrittenAb) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Data)
	return result, nil
}

// UnmarshalCairo deserializes WrittenAb from Cairo felt array
func (s *WrittenAb) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data")
	}
	s.Data = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for WrittenAb
func (s *WrittenAb) CairoSize() int {
	return -1 // Dynamic size
}

// IsSimpleEvent implements the SimpleEvent interface
func (e WrittenAb) IsSimpleEvent() bool {
	return true
}


type OtherWritten struct {
	Data *felt.Felt `json:"data"`
}

// MarshalCairo serializes OtherWritten to Cairo felt array
func (s *OtherWritten) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Data)
	return result, nil
}

// UnmarshalCairo deserializes OtherWritten from Cairo felt array
func (s *OtherWritten) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Data")
	}
	s.Data = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for OtherWritten
func (s *OtherWritten) CairoSize() int {
	return -1 // Dynamic size
}

// IsOtherEvent implements the OtherEvent interface
func (e OtherWritten) IsOtherEvent() bool {
	return true
}


type SimpleWritten struct {
	Before *felt.Felt `json:"before"`
	After *felt.Felt `json:"after"`
}

// MarshalCairo serializes SimpleWritten to Cairo felt array
func (s *SimpleWritten) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Before)
	result = append(result, s.After)
	return result, nil
}

// UnmarshalCairo deserializes SimpleWritten from Cairo felt array
func (s *SimpleWritten) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Before")
	}
	s.Before = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field After")
	}
	s.After = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for SimpleWritten
func (s *SimpleWritten) CairoSize() int {
	return -1 // Dynamic size
}

// IsSimpleEvent implements the SimpleEvent interface
func (e SimpleWritten) IsSimpleEvent() bool {
	return true
}


type ComponentsReader struct {
	contractAddress *felt.Felt
	provider rpc.RpcProvider
}

type ComponentsWriter struct {
	contractAddress *felt.Felt
	account *account.Account
}

type Components struct {
	*ComponentsReader
	*ComponentsWriter
}

func NewComponentsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *ComponentsReader {
	return &ComponentsReader {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func NewComponentsWriter(contractAddress *felt.Felt, account *account.Account) *ComponentsWriter {
	return &ComponentsWriter {
		contractAddress: contractAddress,
		account: account,
	}
}

func NewComponents(contractAddress *felt.Felt, account *account.Account) *Components {
	return &Components {
		ComponentsReader: NewComponentsReader(contractAddress, account.Provider),
		ComponentsWriter: NewComponentsWriter(contractAddress, account),
	}
}

func (components_writer *ComponentsWriter) Simple(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("simple"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (components_writer *ComponentsWriter) SimpleOther(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("simple_other"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (components_writer *ComponentsWriter) ArrayStructSimple(ctx context.Context, opts *cainome.InvokeOpts) ([]MyStructSimple, *felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("array_struct_simple"), calldata, opts)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return nil, txHash, nil
}

func (components_writer *ComponentsWriter) ArrayStructSimpleOther(ctx context.Context, opts *cainome.InvokeOpts) ([]MyStructOther, *felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("array_struct_simple_other"), calldata, opts)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return nil, txHash, nil
}

func (components_writer *ComponentsWriter) TupleEvents(ctx context.Context, opts *cainome.InvokeOpts) (struct {
	Field0 MyStructSimple
	Field1 MyStructOther
}, *felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("tuple_events"), calldata, opts)
	if err != nil {
		return struct {
	Field0 MyStructSimple
	Field1 MyStructOther
}{}, nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return struct {
	Field0 MyStructSimple
	Field1 MyStructOther
}{}, txHash, nil
}

func (components_reader *ComponentsReader) ReadData(ctx context.Context, opts *cainome.CallOpts) (*felt.Felt, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    components_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("read_data"),
		Calldata:           calldata,
	}

	response, err := components_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return nil, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return nil, fmt.Errorf("empty response")
	}
	return response[0], nil
}

func (components_writer *ComponentsWriter) WriteData(ctx context.Context, data *felt.Felt, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	calldata = append(calldata, data)

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, components_writer.account, components_writer.contractAddress, utils.GetSelectorFromNameFelt("write_data"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

