// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/cartridge-gg/cainome"
)

type ConflictingEventsEventOnlyKey struct {
	Value *felt.Felt `json:"value"`
}

// MarshalCairo serializes ConflictingEventsEventOnlyKey to Cairo felt array
func (s *ConflictingEventsEventOnlyKey) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Value)
	return result, nil
}

// UnmarshalCairo deserializes ConflictingEventsEventOnlyKey from Cairo felt array
func (s *ConflictingEventsEventOnlyKey) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Value")
	}
	s.Value = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for ConflictingEventsEventOnlyKey
func (s *ConflictingEventsEventOnlyKey) CairoSize() int {
	return -1 // Dynamic size
}

// IsConflictingEventsEvent implements the ConflictingEventsEvent interface
func (e ConflictingEventsEventOnlyKey) IsConflictingEventsEvent() bool {
	return true
}


// ConflictingEventsEvent represents a contract event
type ConflictingEventsEvent interface {
	IsConflictingEventsEvent() bool
}

const (
	ConflictingEventsEvent_EventOnlyKey = "EventOnlyKey"
)


type ConflictingEventsContract struct {
	contractAddress *felt.Felt
}

func NewConflictingEventsContract(contractAddress *felt.Felt) *ConflictingEventsContract {
	return &ConflictingEventsContract {
		contractAddress: contractAddress,
	}
}

type ConflictingEventsReader struct {
	*ConflictingEventsContract
	provider rpc.RpcProvider
}

type ConflictingEventsWriter struct {
	*ConflictingEventsContract
	account *account.Account
}

type ConflictingEvents struct {
	*ConflictingEventsReader
	*ConflictingEventsWriter
}

func NewConflictingEventsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *ConflictingEventsReader {
	return &ConflictingEventsReader {
		ConflictingEventsContract: NewConflictingEventsContract(contractAddress),
		provider: provider,
	}
}

func NewConflictingEventsWriter(contractAddress *felt.Felt, account *account.Account) *ConflictingEventsWriter {
	return &ConflictingEventsWriter {
		ConflictingEventsContract: NewConflictingEventsContract(contractAddress),
		account: account,
	}
}

func NewConflictingEvents(contractAddress *felt.Felt, account *account.Account) *ConflictingEvents {
	return &ConflictingEvents {
		ConflictingEventsReader: NewConflictingEventsReader(contractAddress, account.Provider),
		ConflictingEventsWriter: NewConflictingEventsWriter(contractAddress, account),
	}
}

type ConflictingEventsEmitSuperResponse struct {
	// This function has no return values
}

func NewConflictingEventsEmitSuperResponse() *ConflictingEventsEmitSuperResponse {
	return &ConflictingEventsEmitSuperResponse{}
}

// MarshalCairo serializes ConflictingEventsEmitSuperResponse to Cairo felt array
func (s *ConflictingEventsEmitSuperResponse) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt


	return result, nil
}

// UnmarshalCairo deserializes ConflictingEventsEmitSuperResponse from Cairo felt array
func (s *ConflictingEventsEmitSuperResponse) UnmarshalCairo(data []*felt.Felt) error {

	return nil
}

// CairoSize returns the serialized size for ConflictingEventsEmitSuperResponse
func (s *ConflictingEventsEmitSuperResponse) CairoSize() int {
	return -1 // Dynamic size
}

func (conflicting_events_contract *ConflictingEventsContract) EmitSuper() (rpc.FunctionCall, error) {
	// Serialize input to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    conflicting_events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_super"),
		Calldata:           calldata,
	}, nil
}

func (conflicting_events_contract *ConflictingEventsContract) EmitSuperLegacy() (rpc.FunctionCall, error) {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}

	return rpc.FunctionCall{
		ContractAddress:    conflicting_events_contract.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("emit_super"),
		Calldata:           calldata,
	}, nil
}

func (conflicting_events_writer *ConflictingEventsWriter) EmitSuper(ctx context.Context, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, conflicting_events_writer.account, conflicting_events_writer.contractAddress, utils.GetSelectorFromNameFelt("emit_super"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

