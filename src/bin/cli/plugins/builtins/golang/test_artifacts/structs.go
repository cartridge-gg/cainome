// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/cartridge-gg/cainome"
	"math/big"
)

type GenericOne struct {
	A *big.Int `json:"a"`
	B *felt.Felt `json:"b"`
	C *big.Int `json:"c"`
}

// MarshalCairo serializes GenericOne to Cairo felt array
func (s *GenericOne) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromBigInt(s.A))
	result = append(result, s.B)
	result = append(result, cainome.FeltFromBigInt(s.C))
	return result, nil
}

// UnmarshalCairo deserializes GenericOne from Cairo felt array
func (s *GenericOne) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field C")
	}
	s.C = cainome.BigIntFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for GenericOne
func (s *GenericOne) CairoSize() int {
	return -1 // Dynamic size
}


type GenericTwo struct {
	A uint64 `json:"a"`
	B uint64 `json:"b"`
	C *felt.Felt `json:"c"`
	D ToAlias `json:"d"`
	E []ToAlias `json:"e"`
	F GenericOne `json:"f"`
}

// MarshalCairo serializes GenericTwo to Cairo felt array
func (s *GenericTwo) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromUint(uint64(s.A)))
	result = append(result, cainome.FeltFromUint(uint64(s.B)))
	result = append(result, s.C)
	// Struct field D: marshal using CairoMarshaler
	if fieldData, err := s.D.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	// Array field E: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.E))))
	for _, item := range s.E {
		if itemData, err := item.MarshalCairo(); err != nil {
			return nil, err
		} else {
			result = append(result, itemData...)
		}
	}
	// Struct field F: marshal using CairoMarshaler
	if fieldData, err := s.F.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	return result, nil
}

// UnmarshalCairo deserializes GenericTwo from Cairo felt array
func (s *GenericTwo) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = cainome.UintFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = cainome.UintFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field C")
	}
	s.C = data[offset]
	offset++

	// Struct field D: unmarshal using CairoMarshaler
	if err := s.D.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	// Array field E: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of E")
	}
	lengthE := cainome.UintFromFelt(data[offset])
	offset++
	s.E = make([]ToAlias, lengthE)
	for i := uint64(0); i < lengthE; i++ {
		var item ToAlias
		if err := item.UnmarshalCairo(data[offset:]); err != nil {
			return err
		}
		s.E[i] = item
		// Calculate consumed felts to update offset
		if itemData, err := item.MarshalCairo(); err != nil {
			return err
		} else {
			offset += len(itemData)
		}
	}

	// Struct field F: unmarshal using CairoMarshaler
	if err := s.F.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	return nil
}

// CairoSize returns the serialized size for GenericTwo
func (s *GenericTwo) CairoSize() int {
	return -1 // Dynamic size
}


type Simple struct {
	Address *felt.Felt `json:"address"`
	ClassHash *felt.Felt `json:"class_hash"`
	EthAddress [20]byte `json:"eth_address"`
	Felt *felt.Felt `json:"felt"`
	Span []*felt.Felt `json:"span"`
	Tuple struct {
	Field0 *felt.Felt
	Field1 *big.Int
} `json:"tuple"`
	Uint256 *big.Int `json:"uint256"`
	Uint64 uint64 `json:"uint64"`
}

// MarshalCairo serializes Simple to Cairo felt array
func (s *Simple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Address)
	result = append(result, s.ClassHash)
	result = append(result, cainome.FeltFromBytes(s.EthAddress[:]))
	result = append(result, s.Felt)
	// Array field Span: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Span))))
	for _, item := range s.Span {
		result = append(result, item)
	}
	// Tuple field Tuple: marshal each sub-field
	result = append(result, s.Tuple.Field0)
	result = append(result, cainome.FeltFromBigInt(s.Tuple.Field1))
	result = append(result, cainome.FeltFromBigInt(s.Uint256))
	result = append(result, cainome.FeltFromUint(uint64(s.Uint64)))
	return result, nil
}

// UnmarshalCairo deserializes Simple from Cairo felt array
func (s *Simple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Address")
	}
	s.Address = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field ClassHash")
	}
	s.ClassHash = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field EthAddress")
	}
	ethBytes := data[offset].Bytes()
	copy(s.EthAddress[:], ethBytes[:])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Felt")
	}
	s.Felt = data[offset]
	offset++

	// Array field Span: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Span")
	}
	lengthSpan := cainome.UintFromFelt(data[offset])
	offset++
	s.Span = make([]*felt.Felt, lengthSpan)
	for i := uint64(0); i < lengthSpan; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of Span", i)
		}
		s.Span[i] = data[offset]
		offset++
	}

	// Tuple field Tuple: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Tuple element 0")
	}
	s.Tuple.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Tuple element 1")
	}
	s.Tuple.Field1 = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint256")
	}
	s.Uint256 = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint64")
	}
	s.Uint64 = cainome.UintFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for Simple
func (s *Simple) CairoSize() int {
	return -1 // Dynamic size
}


type StructWithStruct struct {
	Simple Simple `json:"simple"`
}

// MarshalCairo serializes StructWithStruct to Cairo felt array
func (s *StructWithStruct) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Struct field Simple: marshal using CairoMarshaler
	if fieldData, err := s.Simple.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	return result, nil
}

// UnmarshalCairo deserializes StructWithStruct from Cairo felt array
func (s *StructWithStruct) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Struct field Simple: unmarshal using CairoMarshaler
	if err := s.Simple.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	return nil
}

// CairoSize returns the serialized size for StructWithStruct
func (s *StructWithStruct) CairoSize() int {
	return -1 // Dynamic size
}


type ToAlias struct {
	A uint32 `json:"a"`
}

// MarshalCairo serializes ToAlias to Cairo felt array
func (s *ToAlias) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromUint(uint64(s.A)))
	return result, nil
}

// UnmarshalCairo deserializes ToAlias from Cairo felt array
func (s *ToAlias) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = uint32(cainome.UintFromFelt(data[offset]))
	offset++

	return nil
}

// CairoSize returns the serialized size for ToAlias
func (s *ToAlias) CairoSize() int {
	return -1 // Dynamic size
}


// StructsStructsEvent represents a contract event
type StructsStructsEvent interface {
	IsStructsStructsEvent() bool
}


type StructsReader struct {
	contractAddress *felt.Felt
	provider rpc.RpcProvider
}

type StructsWriter struct {
	contractAddress *felt.Felt
	account *account.Account
}

type Structs struct {
	*StructsReader
	*StructsWriter
}

func NewStructsReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *StructsReader {
	return &StructsReader {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func NewStructsWriter(contractAddress *felt.Felt, account *account.Account) *StructsWriter {
	return &StructsWriter {
		contractAddress: contractAddress,
		account: account,
	}
}

func NewStructs(contractAddress *felt.Felt, account *account.Account) *Structs {
	return &Structs {
		StructsReader: NewStructsReader(contractAddress, account.Provider),
		StructsWriter: NewStructsWriter(contractAddress, account),
	}
}

func (structs_reader *StructsReader) GetGenericOne(ctx context.Context, opts *cainome.CallOpts) (GenericOne, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_one"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericOne{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericOne{}, fmt.Errorf("empty response")
	}
	var result GenericOne
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericOne{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs_reader *StructsReader) GetGenericOneArray(ctx context.Context, opts *cainome.CallOpts) (GenericOne, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_one_array"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericOne{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericOne{}, fmt.Errorf("empty response")
	}
	var result GenericOne
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericOne{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs_reader *StructsReader) GetGenericTwo(ctx context.Context, opts *cainome.CallOpts) (GenericTwo, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_two"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericTwo{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericTwo{}, fmt.Errorf("empty response")
	}
	var result GenericTwo
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericTwo{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs_reader *StructsReader) GetSimple(ctx context.Context, opts *cainome.CallOpts) (Simple, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return Simple{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return Simple{}, fmt.Errorf("empty response")
	}
	var result Simple
	if err := result.UnmarshalCairo(response); err != nil {
		return Simple{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs_reader *StructsReader) GetStructWStruct(ctx context.Context, opts *cainome.CallOpts) (StructWithStruct, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_struct_w_struct"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return StructWithStruct{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return StructWithStruct{}, fmt.Errorf("empty response")
	}
	var result StructWithStruct
	if err := result.UnmarshalCairo(response); err != nil {
		return StructWithStruct{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs_reader *StructsReader) GetTupleOfArrayGeneric(ctx context.Context, opts *cainome.CallOpts) (struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs_reader.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_tuple_of_array_generic"),
		Calldata:           calldata,
	}

	response, err := structs_reader.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, fmt.Errorf("empty response")
	}
	var result struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}
	offset := 0

	if offset >= len(response) {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, fmt.Errorf("insufficient data for tuple field 0")
	}
	// TODO: Handle token type Array(Array { type_path: "core::array::Span::<contracts::abicov::structs::GenericOne::<core::integer::u64>>", inner: Composite(Composite { type_path: "contracts::abicov::structs::GenericOne::<core::integer::u64>", inners: [], generic_args: [("A", CoreBasic(CoreBasic { type_path: "core::integer::u64" }))], type: Unknown, is_event: false, alias: None }), is_legacy: false }) for tuple field 0
	offset++

	if offset >= len(response) {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, fmt.Errorf("insufficient data for tuple field 1")
	}
	// TODO: Handle token type Array(Array { type_path: "core::array::Span::<core::felt252>", inner: CoreBasic(CoreBasic { type_path: "core::felt252" }), is_legacy: false }) for tuple field 1
	offset++

	return result, nil
}

func (structs_writer *StructsWriter) SetFromAlias(ctx context.Context, value []*ToAlias, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	// Array of complex types: serialize length then elements
	calldata = append(calldata, cainome.FeltFromUint(uint64(len(value))))
	for _, item := range value {
		if item_data, err := item.MarshalCairo(); err != nil {
			return nil, fmt.Errorf("failed to marshal value: %w", err)
		} else {
			calldata = append(calldata, item_data...)
		}
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_from_alias"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetGenericOne(ctx context.Context, generic *GenericOne, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal generic: %w", err)
	} else {
		calldata = append(calldata, generic_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_generic_one"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetGenericTwo(ctx context.Context, generic *GenericTwo, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal generic: %w", err)
	} else {
		calldata = append(calldata, generic_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_generic_two"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetGenericTwo0(ctx context.Context, generic *GenericTwo, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal generic: %w", err)
	} else {
		calldata = append(calldata, generic_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_generic_two_0"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetGenericTwo2(ctx context.Context, generic *GenericTwo, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal generic: %w", err)
	} else {
		calldata = append(calldata, generic_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_generic_two_2"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetSimple(ctx context.Context, simple *Simple, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if simple_data, err := simple.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal simple: %w", err)
	} else {
		calldata = append(calldata, simple_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_simple"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetStructWOptionalStruct(ctx context.Context, sws *StructWithStruct, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if sws != nil {
		// Some variant
		calldata = append(calldata, cainome.FeltFromUint(0))
		if sws_data, err := (*sws).MarshalCairo(); err != nil {
			return nil, fmt.Errorf("failed to marshal sws: %w", err)
		} else {
			calldata = append(calldata, sws_data...)
		}
	} else {
		// None variant
		calldata = append(calldata, cainome.FeltFromUint(1))
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_struct_w_optional_struct"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetStructWStruct(ctx context.Context, sws *StructWithStruct, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if sws_data, err := sws.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal sws: %w", err)
	} else {
		calldata = append(calldata, sws_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_struct_w_struct"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

func (structs_writer *StructsWriter) SetTupleGeneric(ctx context.Context, value struct {
	Field0 *GenericOne
	Field1 *GenericTwo
}, opts *cainome.InvokeOpts) (*felt.Felt, error) {
	// Setup invoke options
	if opts == nil {
		opts = &cainome.InvokeOpts{}
	}

	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if field0_data, err := value.Field0.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal value: %w", err)
	} else {
		calldata = append(calldata, field0_data...)
	}
	if field1_data, err := value.Field1.MarshalCairo(); err != nil {
		return nil, fmt.Errorf("failed to marshal value: %w", err)
	} else {
		calldata = append(calldata, field1_data...)
	}

	// Build and send invoke transaction using cainome helper
	txHash, err := cainome.BuildAndSendInvokeTxn(ctx, structs_writer.account, structs_writer.contractAddress, utils.GetSelectorFromNameFelt("set_tuple_generic"), calldata, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to submit invoke transaction: %w", err)
	}

	return txHash, nil
}

