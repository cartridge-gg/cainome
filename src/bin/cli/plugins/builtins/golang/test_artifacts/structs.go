// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package abigen

import (
	"context"
	"fmt"
	"math/big"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/cartridge-gg/cainome"
	"github.com/NethermindEth/starknet.go/utils"
)

type StructWithStruct struct {
	Simple Simple `json:"simple"`
}

// MarshalCairo serializes StructWithStruct to Cairo felt array
func (s *StructWithStruct) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Struct field Simple: marshal using CairoMarshaler
	if fieldData, err := s.Simple.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	return result, nil
}

// UnmarshalCairo deserializes StructWithStruct from Cairo felt array
func (s *StructWithStruct) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Struct field Simple: unmarshal using CairoMarshaler
	if err := s.Simple.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	return nil
}

// CairoSize returns the serialized size for StructWithStruct
func (s *StructWithStruct) CairoSize() int {
	return -1 // Dynamic size
}


type Simple struct {
	Felt *felt.Felt `json:"felt"`
	Uint256 *big.Int `json:"uint256"`
	Uint64 uint64 `json:"uint64"`
	Address *felt.Felt `json:"address"`
	ClassHash *felt.Felt `json:"class_hash"`
	EthAddress [20]byte `json:"eth_address"`
	Tuple struct {
	Field0 *felt.Felt
	Field1 *big.Int
} `json:"tuple"`
	Span []*felt.Felt `json:"span"`
}

// MarshalCairo serializes Simple to Cairo felt array
func (s *Simple) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.Felt)
	result = append(result, cainome.FeltFromBigInt(s.Uint256))
	result = append(result, cainome.FeltFromUint(uint64(s.Uint64)))
	result = append(result, s.Address)
	result = append(result, s.ClassHash)
	// TODO: Handle builtin composite core::starknet::eth_address::EthAddress for field EthAddress
	// Tuple field Tuple: marshal each sub-field
	result = append(result, s.Tuple.Field0)
	result = append(result, cainome.FeltFromBigInt(s.Tuple.Field1))
	// Array field Span: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Span))))
	for _, item := range s.Span {
		result = append(result, item)
	}
	return result, nil
}

// UnmarshalCairo deserializes Simple from Cairo felt array
func (s *Simple) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Felt")
	}
	s.Felt = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint256")
	}
	s.Uint256 = cainome.BigIntFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Uint64")
	}
	s.Uint64 = cainome.UintFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Address")
	}
	s.Address = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field ClassHash")
	}
	s.ClassHash = data[offset]
	offset++

	// TODO: Handle builtin composite core::starknet::eth_address::EthAddress for field EthAddress unmarshal
	_ = offset // Suppress unused variable warning
	// Tuple field Tuple: unmarshal each sub-field
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Tuple element 0")
	}
	s.Tuple.Field0 = data[offset]
	offset++
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Tuple element 1")
	}
	s.Tuple.Field1 = cainome.BigIntFromFelt(data[offset])
	offset++

	// Array field Span: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Span")
	}
	lengthSpan := cainome.UintFromFelt(data[offset])
	offset++
	s.Span = make([]*felt.Felt, lengthSpan)
	for i := uint64(0); i < lengthSpan; i++ {
		if offset >= len(data) {
			return fmt.Errorf("insufficient data for array element %d of Span", i)
		}
		s.Span[i] = data[offset]
		offset++
	}

	return nil
}

// CairoSize returns the serialized size for Simple
func (s *Simple) CairoSize() int {
	return -1 // Dynamic size
}


type GenericOne struct {
	A ToAlias `json:"a"`
	B *felt.Felt `json:"b"`
	C *big.Int `json:"c"`
}

// MarshalCairo serializes GenericOne to Cairo felt array
func (s *GenericOne) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Struct field A: marshal using CairoMarshaler
	if fieldData, err := s.A.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	result = append(result, s.B)
	result = append(result, cainome.FeltFromBigInt(s.C))
	return result, nil
}

// UnmarshalCairo deserializes GenericOne from Cairo felt array
func (s *GenericOne) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Struct field A: unmarshal using CairoMarshaler
	if err := s.A.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field C")
	}
	s.C = cainome.BigIntFromFelt(data[offset])
	offset++

	return nil
}

// CairoSize returns the serialized size for GenericOne
func (s *GenericOne) CairoSize() int {
	return -1 // Dynamic size
}


// StructsEvent represents a contract event
type StructsEvent interface {
	IsStructsEvent() bool
}


type GenericTwo struct {
	A *felt.Felt `json:"a"`
	B uint64 `json:"b"`
	C *felt.Felt `json:"c"`
	D ToAlias `json:"d"`
	E []ToAlias `json:"e"`
	F GenericOne `json:"f"`
}

// MarshalCairo serializes GenericTwo to Cairo felt array
func (s *GenericTwo) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, s.A)
	result = append(result, cainome.FeltFromUint(uint64(s.B)))
	result = append(result, s.C)
	// Struct field D: marshal using CairoMarshaler
	if fieldData, err := s.D.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	// Array field E: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.E))))
	for _, item := range s.E {
		if itemData, err := item.MarshalCairo(); err != nil {
			return nil, err
		} else {
			result = append(result, itemData...)
		}
	}
	// Struct field F: marshal using CairoMarshaler
	if fieldData, err := s.F.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	return result, nil
}

// UnmarshalCairo deserializes GenericTwo from Cairo felt array
func (s *GenericTwo) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = data[offset]
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field B")
	}
	s.B = cainome.UintFromFelt(data[offset])
	offset++

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field C")
	}
	s.C = data[offset]
	offset++

	// Struct field D: unmarshal using CairoMarshaler
	if err := s.D.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	// Array field E: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of E")
	}
	lengthE := cainome.UintFromFelt(data[offset])
	offset++
	s.E = make([]ToAlias, lengthE)
	for i := uint64(0); i < lengthE; i++ {
		var item ToAlias
		if err := item.UnmarshalCairo(data[offset:]); err != nil {
			return err
		}
		s.E[i] = item
		// Calculate consumed felts to update offset
		if itemData, err := item.MarshalCairo(); err != nil {
			return err
		} else {
			offset += len(itemData)
		}
	}

	// Struct field F: unmarshal using CairoMarshaler
	if err := s.F.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// TODO: Update offset based on consumed data

	return nil
}

// CairoSize returns the serialized size for GenericTwo
func (s *GenericTwo) CairoSize() int {
	return -1 // Dynamic size
}


type ToAlias struct {
	A uint32 `json:"a"`
}

// MarshalCairo serializes ToAlias to Cairo felt array
func (s *ToAlias) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	result = append(result, cainome.FeltFromUint(uint64(s.A)))
	return result, nil
}

// UnmarshalCairo deserializes ToAlias from Cairo felt array
func (s *ToAlias) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field A")
	}
	s.A = uint32(cainome.UintFromFelt(data[offset]))
	offset++

	return nil
}

// CairoSize returns the serialized size for ToAlias
func (s *ToAlias) CairoSize() int {
	return -1 // Dynamic size
}


type Structs struct {
	contractAddress *felt.Felt
	provider *rpc.Provider
}

func NewStructs(contractAddress *felt.Felt, provider *rpc.Provider) *Structs {
	return &Structs {
		contractAddress: contractAddress,
		provider: provider,
	}
}

func (structs *Structs) GetSimple(ctx context.Context, opts *cainome.CallOpts) (Simple, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_simple"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return Simple{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return Simple{}, fmt.Errorf("empty response")
	}
	var result Simple
	if err := result.UnmarshalCairo(response); err != nil {
		return Simple{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs *Structs) SetSimple(ctx context.Context, simple *Simple) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if simple_data, err := simple.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, simple_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) GetStructWStruct(ctx context.Context, opts *cainome.CallOpts) (StructWithStruct, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_struct_w_struct"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return StructWithStruct{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return StructWithStruct{}, fmt.Errorf("empty response")
	}
	var result StructWithStruct
	if err := result.UnmarshalCairo(response); err != nil {
		return StructWithStruct{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs *Structs) SetStructWStruct(ctx context.Context, sws *StructWithStruct) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if sws_data, err := sws.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, sws_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) GetGenericOne(ctx context.Context, opts *cainome.CallOpts) (GenericOne, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_one"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericOne{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericOne{}, fmt.Errorf("empty response")
	}
	var result GenericOne
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericOne{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs *Structs) GetGenericOneArray(ctx context.Context, opts *cainome.CallOpts) (GenericOne, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_one_array"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericOne{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericOne{}, fmt.Errorf("empty response")
	}
	var result GenericOne
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericOne{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs *Structs) SetGenericOne(ctx context.Context, generic *GenericOne) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, generic_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) SetGenericTwo2(ctx context.Context, generic *GenericTwo) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, generic_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) SetGenericTwo0(ctx context.Context, generic *GenericTwo) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, generic_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) SetGenericTwo(ctx context.Context, generic *GenericTwo) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	if generic_data, err := generic.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, generic_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) GetGenericTwo(ctx context.Context, opts *cainome.CallOpts) (GenericTwo, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_generic_two"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return GenericTwo{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return GenericTwo{}, fmt.Errorf("empty response")
	}
	var result GenericTwo
	if err := result.UnmarshalCairo(response); err != nil {
		return GenericTwo{}, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return result, nil
}

func (structs *Structs) SetTupleGeneric(ctx context.Context, value struct {
	Field0 *GenericOne
	Field1 *GenericTwo
}) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	// Tuple field value: marshal each sub-field
	if value_Field0_data, err := value.Field0.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, value_Field0_data...)
	}
	if value_Field1_data, err := value.Field1.MarshalCairo(); err != nil {
		return err
	} else {
		calldata = append(calldata, value_Field1_data...)
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

func (structs *Structs) GetTupleOfArrayGeneric(ctx context.Context, opts *cainome.CallOpts) (struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}, error) {
	// Setup call options
	if opts == nil {
		opts = &cainome.CallOpts{}
	}
	var blockID rpc.BlockID
	if opts.BlockID != nil {
		blockID = *opts.BlockID
	} else {
		blockID = rpc.BlockID{Tag: "latest"}
	}

	// No parameters required
	calldata := []*felt.Felt{}

	// Make the contract call
	functionCall := rpc.FunctionCall{
		ContractAddress:    structs.contractAddress,
		EntryPointSelector: utils.GetSelectorFromNameFelt("get_tuple_of_array_generic"),
		Calldata:           calldata,
	}

	response, err := structs.provider.Call(ctx, functionCall, blockID)
	if err != nil {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, err
	}

	// Deserialize response to proper type
	if len(response) == 0 {
		return struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}{}, fmt.Errorf("empty response")
	}
	var result struct {
	Field0 []GenericOne
	Field1 []*felt.Felt
}
	// TODO: Convert felt to Tuple(Tuple { type_path: "(core::array::Span::<contracts::abicov::structs::GenericOne::<core::integer::u64>>, core::array::Span::<core::felt252>)", inners: [Array(Array { type_path: "core::array::Span::<contracts::abicov::structs::GenericOne::<core::integer::u64>>", inner: Composite(Composite { type_path: "contracts::abicov::structs::GenericOne::<core::integer::u64>", inners: [], generic_args: [("A", CoreBasic(CoreBasic { type_path: "core::integer::u64" }))], type: Unknown, is_event: false, alias: None }), is_legacy: false }), Array(Array { type_path: "core::array::Span::<core::felt252>", inner: CoreBasic(CoreBasic { type_path: "core::felt252" }), is_legacy: false })] })
	_ = response
	return result, nil
}

func (structs *Structs) SetFromAlias(ctx context.Context, value []*ToAlias) error {
	// Serialize parameters to calldata
	calldata := []*felt.Felt{}
	// Array field value: serialize length then elements
	calldata = append(calldata, cainome.FeltFromUint(uint64(len(value))))
	for _, item := range value {
		if item_data, err := item.MarshalCairo(); err != nil {
			return fmt.Errorf("failed to marshal array item: %w", err)
		} else {
			calldata = append(calldata, item_data...)
		}
	}

	// TODO: Implement invoke transaction
	// This requires account/signer setup for transaction submission
	_ = calldata
	return fmt.Errorf("invoke methods require account setup - not yet implemented")
}

