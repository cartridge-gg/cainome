use anyhow::Result;
use cainome_parser::tokens::StateMutability;
use cainome_parser::{AbiParser, TokenizedAbi};
use camino::Utf8PathBuf;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use std::collections::HashMap;
use std::fmt;
use std::fs;
use std::io;

mod execution_version;
mod expand;
pub use execution_version::{ExecutionVersion, ParseExecutionVersionError};

use crate::expand::utils;
use crate::expand::{CairoContract, CairoEnum, CairoEnumEvent, CairoFunction, CairoStruct};

///Type-safe contract bindings generated by Abigen.
#[derive(Clone)]
pub struct ContractBindings {
    /// Name of the contract.
    pub name: String,
    /// Tokenized ABI written to a `[TokenStream2]`.
    pub tokens: TokenStream2,
}

impl ContractBindings {
    /// Writes the bindings to the specified file.
    ///
    /// # Arguments
    ///
    /// * `file` - The path to the file to write the bindings to.
    pub fn write_to_file(&self, file: &str) -> io::Result<()> {
        let content = format!(
            "// ****\n// Auto-generated by cainome do not edit.\n// ****\n\n#![allow(clippy::all)]\n#![allow(warnings)]\n\n{}",
            self
        );
        fs::write(file, content)
    }
}

impl fmt::Display for ContractBindings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let syntax_tree = syn::parse2::<syn::File>(self.tokens.clone()).unwrap();
        let s = prettyplease::unparse(&syntax_tree);
        f.write_str(&s)
    }
}

impl fmt::Debug for ContractBindings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ContractBindings")
            .field("name", &self.name)
            .finish()
    }
}

/// Programmatically generate type-safe Rust bindings for an Starknet smart contract from its ABI.
///
/// Currently only one contract at a time is supported.
#[derive(Debug, Clone)]
pub struct Abigen {
    /// Name of the contract, used as the variable name in the generated code
    /// to identify the contract.
    pub contract_name: String,
    /// The path to a sierra artifact or a JSON with ABI entries only.
    pub abi_source: Utf8PathBuf,
    /// Types aliases to avoid name conflicts, as for now the types are limited to the
    /// latest segment of the fully qualified path.
    pub types_aliases: HashMap<String, String>,
    /// The version of transaction to be executed.
    pub execution_version: ExecutionVersion,
    /// Derives to be added to the generated types.
    pub derives: Vec<String>,
    /// Derives to be added to the generated contract.
    pub contract_derives: Vec<String>,
    /// Types to be skipped from the generated types, usually combined with the `types_aliases` to
    /// let the user specify the implementation of the types. If a type is generic, the generic arguments
    /// are not part of the compared name.
    pub type_skips: Vec<String>,
}

impl Abigen {
    /// Creates a new instance of `Abigen`.
    ///
    /// # Arguments
    ///
    /// * `contract_name` - Name of the contract, used as the variable name in the generated code
    ///   to identify the contract.
    /// * `abi_source` - The path to a sierra artifact or a JSON with ABI entries only.
    pub fn new(contract_name: &str, abi_source: &str) -> Self {
        Self {
            contract_name: contract_name.to_string(),
            abi_source: Utf8PathBuf::from(abi_source),
            types_aliases: HashMap::new(),
            execution_version: ExecutionVersion::V1,
            derives: vec![],
            contract_derives: vec![],
            type_skips: vec![],
        }
    }

    /// Sets the types aliases to avoid name conflicts.
    ///
    /// # Arguments
    ///
    /// * `types_aliases` - Types aliases to avoid name conflicts.
    pub fn with_types_aliases(mut self, types_aliases: HashMap<String, String>) -> Self {
        self.types_aliases = types_aliases;
        self
    }

    /// Sets the execution version to be used.
    ///
    /// # Arguments
    ///
    /// * `execution_version` - The version of transaction to be executed.
    pub fn with_execution_version(mut self, execution_version: ExecutionVersion) -> Self {
        self.execution_version = execution_version;
        self
    }

    /// Sets the derives to be added to the generated types.
    ///
    /// # Arguments
    ///
    /// * `derives` - Derives to be added to the generated types.
    pub fn with_derives(mut self, derives: Vec<String>) -> Self {
        self.derives = derives;
        self
    }

    /// Sets the derives to be added to the generated contract.
    ///
    /// # Arguments
    ///
    /// * `derives` - Derives to be added to the generated contract.
    pub fn with_contract_derives(mut self, derives: Vec<String>) -> Self {
        self.contract_derives = derives;
        self
    }

    /// Sets the types to be skipped from the generated types.
    ///
    /// # Arguments
    ///
    /// * `type_skips` - Types to be skipped from the generated types.
    pub fn with_type_skips(mut self, type_skips: Vec<String>) -> Self {
        self.type_skips = type_skips;
        self
    }
    /// Generates the contract bindings.
    pub fn generate(&self) -> Result<ContractBindings> {
        let file_content = std::fs::read_to_string(&self.abi_source)?;

        match AbiParser::tokens_from_abi_string(&file_content, &self.types_aliases) {
            Ok(tokens) => {
                let expanded = abi_to_tokenstream(
                    &self.contract_name,
                    &tokens,
                    self.execution_version,
                    &self.derives,
                    &self.contract_derives,
                    &self.type_skips,
                );

                Ok(ContractBindings {
                    name: self.contract_name.clone(),
                    tokens: expanded,
                })
            }
            Err(e) => {
                anyhow::bail!(
                    "Abi source {} could not be parsed {:?}. ABI file should be a JSON with an array of abi entries or a Sierra artifact.",
                    self.abi_source, e
                )
            }
        }
    }
}

/// Converts the given ABI (in it's tokenize form) into rust bindings.
///
/// # Arguments
///
/// * `contract_name` - Name of the contract.
/// * `abi_tokens` - Tokenized ABI.
/// * `execution_version` - The version of transaction to be executed.
/// * `derives` - Derives to be added to the generated types.
/// * `contract_derives` - Derives to be added to the generated contract.
/// * `type_skips` - Types to be skipped from the generated types.
pub fn abi_to_tokenstream(
    contract_name: &str,
    abi_tokens: &TokenizedAbi,
    execution_version: ExecutionVersion,
    derives: &[String],
    contract_derives: &[String],
    type_skips: &[String],
) -> TokenStream2 {
    let type_skips = type_skips
        .iter()
        .map(|s| s.replace(" ", ""))
        .collect::<Vec<String>>();
    let contract_name = utils::str_to_ident(contract_name);

    let mut tokens: Vec<TokenStream2> = vec![];

    tokens.push(CairoContract::expand(
        contract_name.clone(),
        contract_derives,
    ));

    let mut sorted_structs = abi_tokens.structs.clone();
    sorted_structs.sort_by(|a, b| {
        let a_name = a
            .to_composite()
            .expect("composite expected")
            .type_name_or_alias();
        let b_name = b
            .to_composite()
            .expect("composite expected")
            .type_name_or_alias();
        a_name.cmp(&b_name)
    });

    let mut sorted_enums = abi_tokens.enums.clone();
    sorted_enums.sort_by(|a, b| {
        let a_name = a
            .to_composite()
            .expect("composite expected")
            .type_name_or_alias();
        let b_name = b
            .to_composite()
            .expect("composite expected")
            .type_name_or_alias();
        a_name.cmp(&b_name)
    });

    for s in &sorted_structs {
        let s_composite = s.to_composite().expect("composite expected");

        if type_skips.contains(&s_composite.type_path_no_generic()) {
            continue;
        }

        tokens.push(CairoStruct::expand_decl(s_composite, derives));
        tokens.push(CairoStruct::expand_impl(s_composite));
    }

    for e in &sorted_enums {
        let e_composite = e.to_composite().expect("composite expected");
        tokens.push(CairoEnum::expand_decl(e_composite, derives));
        tokens.push(CairoEnum::expand_impl(e_composite));

        if type_skips.contains(&e_composite.type_path_no_generic()) {
            continue;
        }

        tokens.push(CairoEnumEvent::expand(
            e.to_composite().expect("composite expected"),
            &abi_tokens.enums,
            &abi_tokens.structs,
        ));
    }

    let mut reader_views = vec![];
    let mut views = vec![];
    let mut externals = vec![];

    // Interfaces are not yet reflected in the generated contract.
    // Then, the standalone functions and functions from interfaces are put together.
    let mut functions = abi_tokens.functions.clone();
    for funcs in abi_tokens.interfaces.values() {
        functions.extend(funcs.clone());
    }

    functions.sort_by(|a, b| {
        let a_name = a.to_function().expect("function expected").name.to_string();
        let b_name = b.to_function().expect("function expected").name.to_string();
        a_name.cmp(&b_name)
    });

    for f in functions {
        let f = f.to_function().expect("function expected");
        match f.state_mutability {
            StateMutability::View => {
                reader_views.push(CairoFunction::expand(f, true, execution_version));
                views.push(CairoFunction::expand(f, false, execution_version));
            }
            StateMutability::External => {
                externals.push(CairoFunction::expand(f, false, execution_version))
            }
        }
    }

    let reader = utils::str_to_ident(format!("{}Reader", contract_name).as_str());

    tokens.push(quote! {
        impl<A: starknet::accounts::ConnectedAccount + Sync> #contract_name<A> {
            #(#views)*
            #(#externals)*
        }

        impl<P: starknet::providers::Provider + Sync> #reader<P> {
            #(#reader_views)*
        }
    });

    let expanded = quote! {
        #(#tokens)*
    };

    expanded
}
