// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package test

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/cartridge-gg/cainome"
)

type DojoStarterDirectionsAvailableDirectionsAvailable struct {
	Directions []DojoStarterDirectionsAvailableDirection `json:"directions"`
	Player *felt.Felt `json:"player"`
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionsAvailable to Cairo felt array
func (s *DojoStarterDirectionsAvailableDirectionsAvailable) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Array field Directions: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Directions))))
	for _, item := range s.Directions {
		if itemData, err := item.MarshalCairo(); err != nil {
			return nil, err
		} else {
			result = append(result, itemData...)
		}
	}
	result = append(result, s.Player)
	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionsAvailable from Cairo felt array
func (s *DojoStarterDirectionsAvailableDirectionsAvailable) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Array field Directions: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Directions")
	}
	lengthDirections := cainome.UintFromFelt(data[offset])
	offset++
	s.Directions = make([]DojoStarterDirectionsAvailableDirection, lengthDirections)
	for i := uint64(0); i < lengthDirections; i++ {
		var item DojoStarterDirectionsAvailableDirection
		if err := item.UnmarshalCairo(data[offset:]); err != nil {
			return err
		}
		s.Directions[i] = item
		// Calculate consumed felts to update offset
		if itemData, err := item.MarshalCairo(); err != nil {
			return err
		} else {
			offset += len(itemData)
		}
	}

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Player")
	}
	s.Player = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionsAvailable
func (s *DojoStarterDirectionsAvailableDirectionsAvailable) CairoSize() int {
	return -1 // Dynamic size
}


// DojoStarterDirectionsAvailableDirection represents a Cairo enum type
type DojoStarterDirectionsAvailableDirection interface {
	IsDojoStarterDirectionsAvailableDirection() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	DojoStarterDirectionsAvailableDirection_Down = "Down"
	DojoStarterDirectionsAvailableDirection_Left = "Left"
	DojoStarterDirectionsAvailableDirection_None = "None"
	DojoStarterDirectionsAvailableDirection_Right = "Right"
	DojoStarterDirectionsAvailableDirection_Up = "Up"
)

type DojoStarterDirectionsAvailableDirectionDown struct {}

func NewDojoStarterDirectionsAvailableDirectionDown() DojoStarterDirectionsAvailableDirectionDown {
	return DojoStarterDirectionsAvailableDirectionDown{}
}

// IsDojoStarterDirectionsAvailableDirection implements the DojoStarterDirectionsAvailableDirection interface
func (d DojoStarterDirectionsAvailableDirectionDown) IsDojoStarterDirectionsAvailableDirection() bool {
	return true
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionDown to Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionDown) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(4))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionDown from Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionDown) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 4 {
		return fmt.Errorf("expected discriminant 4, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionDown
func (d *DojoStarterDirectionsAvailableDirectionDown) CairoSize() int {
	return -1 // Dynamic size
}

type DojoStarterDirectionsAvailableDirectionLeft struct {}

func NewDojoStarterDirectionsAvailableDirectionLeft() DojoStarterDirectionsAvailableDirectionLeft {
	return DojoStarterDirectionsAvailableDirectionLeft{}
}

// IsDojoStarterDirectionsAvailableDirection implements the DojoStarterDirectionsAvailableDirection interface
func (l DojoStarterDirectionsAvailableDirectionLeft) IsDojoStarterDirectionsAvailableDirection() bool {
	return true
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionLeft to Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionLeft) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionLeft from Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionLeft) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionLeft
func (d *DojoStarterDirectionsAvailableDirectionLeft) CairoSize() int {
	return -1 // Dynamic size
}

type DojoStarterDirectionsAvailableDirectionNone struct {}

func NewDojoStarterDirectionsAvailableDirectionNone() DojoStarterDirectionsAvailableDirectionNone {
	return DojoStarterDirectionsAvailableDirectionNone{}
}

// IsDojoStarterDirectionsAvailableDirection implements the DojoStarterDirectionsAvailableDirection interface
func (n DojoStarterDirectionsAvailableDirectionNone) IsDojoStarterDirectionsAvailableDirection() bool {
	return true
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionNone to Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionNone) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionNone from Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionNone) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionNone
func (d *DojoStarterDirectionsAvailableDirectionNone) CairoSize() int {
	return -1 // Dynamic size
}

type DojoStarterDirectionsAvailableDirectionRight struct {}

func NewDojoStarterDirectionsAvailableDirectionRight() DojoStarterDirectionsAvailableDirectionRight {
	return DojoStarterDirectionsAvailableDirectionRight{}
}

// IsDojoStarterDirectionsAvailableDirection implements the DojoStarterDirectionsAvailableDirection interface
func (r DojoStarterDirectionsAvailableDirectionRight) IsDojoStarterDirectionsAvailableDirection() bool {
	return true
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionRight to Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionRight) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(2))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionRight from Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionRight) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 2 {
		return fmt.Errorf("expected discriminant 2, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionRight
func (d *DojoStarterDirectionsAvailableDirectionRight) CairoSize() int {
	return -1 // Dynamic size
}

type DojoStarterDirectionsAvailableDirectionUp struct {}

func NewDojoStarterDirectionsAvailableDirectionUp() DojoStarterDirectionsAvailableDirectionUp {
	return DojoStarterDirectionsAvailableDirectionUp{}
}

// IsDojoStarterDirectionsAvailableDirection implements the DojoStarterDirectionsAvailableDirection interface
func (u DojoStarterDirectionsAvailableDirectionUp) IsDojoStarterDirectionsAvailableDirection() bool {
	return true
}

// MarshalCairo serializes DojoStarterDirectionsAvailableDirectionUp to Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionUp) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(3))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes DojoStarterDirectionsAvailableDirectionUp from Cairo felt array
func (d *DojoStarterDirectionsAvailableDirectionUp) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 3 {
		return fmt.Errorf("expected discriminant 3, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for DojoStarterDirectionsAvailableDirectionUp
func (d *DojoStarterDirectionsAvailableDirectionUp) CairoSize() int {
	return -1 // Dynamic size
}


type DojoStarterDirectionsAvailableContract struct {
	contractAddress *felt.Felt
}

func NewDojoStarterDirectionsAvailableContract(contractAddress *felt.Felt) *DojoStarterDirectionsAvailableContract {
	return &DojoStarterDirectionsAvailableContract {
		contractAddress: contractAddress,
	}
}

type DojoStarterDirectionsAvailableReader struct {
	*DojoStarterDirectionsAvailableContract
	provider rpc.RpcProvider
}

type DojoStarterDirectionsAvailableWriter struct {
	*DojoStarterDirectionsAvailableContract
	account *account.Account
}

type DojoStarterDirectionsAvailable struct {
	*DojoStarterDirectionsAvailableReader
	*DojoStarterDirectionsAvailableWriter
}

func NewDojoStarterDirectionsAvailableReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *DojoStarterDirectionsAvailableReader {
	return &DojoStarterDirectionsAvailableReader {
		DojoStarterDirectionsAvailableContract: NewDojoStarterDirectionsAvailableContract(contractAddress),
		provider: provider,
	}
}

func NewDojoStarterDirectionsAvailableWriter(contractAddress *felt.Felt, account *account.Account) *DojoStarterDirectionsAvailableWriter {
	return &DojoStarterDirectionsAvailableWriter {
		DojoStarterDirectionsAvailableContract: NewDojoStarterDirectionsAvailableContract(contractAddress),
		account: account,
	}
}

func NewDojoStarterDirectionsAvailable(contractAddress *felt.Felt, account *account.Account) *DojoStarterDirectionsAvailable {
	return &DojoStarterDirectionsAvailable {
		DojoStarterDirectionsAvailableReader: NewDojoStarterDirectionsAvailableReader(contractAddress, account.Provider),
		DojoStarterDirectionsAvailableWriter: NewDojoStarterDirectionsAvailableWriter(contractAddress, account),
	}
}

