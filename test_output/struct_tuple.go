// Code generated by Cainome. DO NOT EDIT.
// Generated from ABI file.

package test

import (
	"context"
	"fmt"
	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/cartridge-gg/cainome"
)

type StructTupleDirectionsAvailable struct {
	Directions []struct {
	Field0 StructTupleDirection
	Field1 uint32
} `json:"directions"`
	Player *felt.Felt `json:"player"`
	Test struct {
	Field0 StructTupleDirection
	Field1 *felt.Felt
} `json:"test"`
}

// MarshalCairo serializes StructTupleDirectionsAvailable to Cairo felt array
func (s *StructTupleDirectionsAvailable) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Array field Directions: serialize length then elements
	result = append(result, cainome.FeltFromUint(uint64(len(s.Directions))))
	for _, item := range s.Directions {
		// TODO: Handle unknown token type in array
		_ = item
	}
	result = append(result, s.Player)
	// Tuple field Test: marshal each sub-field (tuple has 2 elements)
	if fieldData, err := s.Test.Field0.MarshalCairo(); err != nil {
		return nil, err
	} else {
		result = append(result, fieldData...)
	}
	result = append(result, s.Test.Field1)
	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionsAvailable from Cairo felt array
func (s *StructTupleDirectionsAvailable) UnmarshalCairo(data []*felt.Felt) error {
	offset := 0

	// Array field Directions: read length then elements
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for array length of Directions")
	}
	lengthDirections := cainome.UintFromFelt(data[offset])
	offset++
	s.Directions = make([]struct {
	Field0 StructTupleDirection
	Field1 uint32
}, lengthDirections)
	for i := uint64(0); i < lengthDirections; i++ {
		// TODO: Handle unknown token type in array unmarshal
	}

	if offset >= len(data) {
		return fmt.Errorf("insufficient data for field Player")
	}
	s.Player = data[offset]
	offset++

	// Tuple field Test: unmarshal each sub-field
	if err := s.Test.Field0.UnmarshalCairo(data[offset:]); err != nil {
		return err
	}
	// Calculate consumed felts to update offset
	if itemData, err := s.Test.Field0.MarshalCairo(); err != nil {
		return err
	} else {
		offset += len(itemData)
	}
	if offset >= len(data) {
		return fmt.Errorf("insufficient data for tuple field Test element 1")
	}
	s.Test.Field1 = data[offset]
	offset++

	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionsAvailable
func (s *StructTupleDirectionsAvailable) CairoSize() int {
	return -1 // Dynamic size
}


// StructTupleDirection represents a Cairo enum type
type StructTupleDirection interface {
	IsStructTupleDirection() bool
	MarshalCairo() ([]*felt.Felt, error)
	UnmarshalCairo(data []*felt.Felt) error
}

const (
	StructTupleDirection_Down = "Down"
	StructTupleDirection_Left = "Left"
	StructTupleDirection_None = "None"
	StructTupleDirection_Right = "Right"
	StructTupleDirection_Up = "Up"
)

type StructTupleDirectionDown struct {}

func NewStructTupleDirectionDown() StructTupleDirectionDown {
	return StructTupleDirectionDown{}
}

// IsStructTupleDirection implements the StructTupleDirection interface
func (d StructTupleDirectionDown) IsStructTupleDirection() bool {
	return true
}

// MarshalCairo serializes StructTupleDirectionDown to Cairo felt array
func (s *StructTupleDirectionDown) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(4))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionDown from Cairo felt array
func (s *StructTupleDirectionDown) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 4 {
		return fmt.Errorf("expected discriminant 4, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionDown
func (s *StructTupleDirectionDown) CairoSize() int {
	return -1 // Dynamic size
}

type StructTupleDirectionLeft struct {}

func NewStructTupleDirectionLeft() StructTupleDirectionLeft {
	return StructTupleDirectionLeft{}
}

// IsStructTupleDirection implements the StructTupleDirection interface
func (l StructTupleDirectionLeft) IsStructTupleDirection() bool {
	return true
}

// MarshalCairo serializes StructTupleDirectionLeft to Cairo felt array
func (s *StructTupleDirectionLeft) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(1))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionLeft from Cairo felt array
func (s *StructTupleDirectionLeft) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 1 {
		return fmt.Errorf("expected discriminant 1, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionLeft
func (s *StructTupleDirectionLeft) CairoSize() int {
	return -1 // Dynamic size
}

type StructTupleDirectionNone struct {}

func NewStructTupleDirectionNone() StructTupleDirectionNone {
	return StructTupleDirectionNone{}
}

// IsStructTupleDirection implements the StructTupleDirection interface
func (n StructTupleDirectionNone) IsStructTupleDirection() bool {
	return true
}

// MarshalCairo serializes StructTupleDirectionNone to Cairo felt array
func (s *StructTupleDirectionNone) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(0))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionNone from Cairo felt array
func (s *StructTupleDirectionNone) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 0 {
		return fmt.Errorf("expected discriminant 0, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionNone
func (s *StructTupleDirectionNone) CairoSize() int {
	return -1 // Dynamic size
}

type StructTupleDirectionRight struct {}

func NewStructTupleDirectionRight() StructTupleDirectionRight {
	return StructTupleDirectionRight{}
}

// IsStructTupleDirection implements the StructTupleDirection interface
func (r StructTupleDirectionRight) IsStructTupleDirection() bool {
	return true
}

// MarshalCairo serializes StructTupleDirectionRight to Cairo felt array
func (s *StructTupleDirectionRight) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(2))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionRight from Cairo felt array
func (s *StructTupleDirectionRight) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 2 {
		return fmt.Errorf("expected discriminant 2, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionRight
func (s *StructTupleDirectionRight) CairoSize() int {
	return -1 // Dynamic size
}

type StructTupleDirectionUp struct {}

func NewStructTupleDirectionUp() StructTupleDirectionUp {
	return StructTupleDirectionUp{}
}

// IsStructTupleDirection implements the StructTupleDirection interface
func (u StructTupleDirectionUp) IsStructTupleDirection() bool {
	return true
}

// MarshalCairo serializes StructTupleDirectionUp to Cairo felt array
func (s *StructTupleDirectionUp) MarshalCairo() ([]*felt.Felt, error) {
	var result []*felt.Felt

	// Discriminant for variant
	result = append(result, cainome.FeltFromUint(3))
	// Unit variant - no additional data

	return result, nil
}

// UnmarshalCairo deserializes StructTupleDirectionUp from Cairo felt array
func (s *StructTupleDirectionUp) UnmarshalCairo(data []*felt.Felt) error {
	if len(data) == 0 {
		return fmt.Errorf("insufficient data for enum discriminant")
	}

	discriminant := cainome.UintFromFelt(data[0])
	if discriminant != 3 {
		return fmt.Errorf("expected discriminant 3, got %d", discriminant)
	}
	offset := 1

	// Unit variant - no additional data to unmarshal
	_ = offset // Suppress unused variable warning
	return nil
}

// CairoSize returns the serialized size for StructTupleDirectionUp
func (s *StructTupleDirectionUp) CairoSize() int {
	return -1 // Dynamic size
}


type StructTupleContract struct {
	contractAddress *felt.Felt
}

func NewStructTupleContract(contractAddress *felt.Felt) *StructTupleContract {
	return &StructTupleContract {
		contractAddress: contractAddress,
	}
}

type StructTupleReader struct {
	*StructTupleContract
	provider rpc.RpcProvider
}

type StructTupleWriter struct {
	*StructTupleContract
	account *account.Account
}

type StructTuple struct {
	*StructTupleReader
	*StructTupleWriter
}

func NewStructTupleReader(contractAddress *felt.Felt, provider rpc.RpcProvider) *StructTupleReader {
	return &StructTupleReader {
		StructTupleContract: NewStructTupleContract(contractAddress),
		provider: provider,
	}
}

func NewStructTupleWriter(contractAddress *felt.Felt, account *account.Account) *StructTupleWriter {
	return &StructTupleWriter {
		StructTupleContract: NewStructTupleContract(contractAddress),
		account: account,
	}
}

func NewStructTuple(contractAddress *felt.Felt, account *account.Account) *StructTuple {
	return &StructTuple {
		StructTupleReader: NewStructTupleReader(contractAddress, account.Provider),
		StructTupleWriter: NewStructTupleWriter(contractAddress, account),
	}
}

